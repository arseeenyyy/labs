========================
|			     	   |	
|ЛАБОРАТОРНАЯ РАБОТА №1|
|			     	   |
========================	

=====Вопросы к защите===== 
1)Архитектура ANSI-SPARC
2)Модель "Сущность - Связь". Классификация сущностей, Виды связей, Ограничения целлостности
3)DDL(Data Defenition Language) - язык определения данных
4)DML(Data Manipulation Language) - язык изменения данных
==========================


=====АРХИТЕКТУРА ANSI-SPARC=====
SPARC - Standart Planning And Requirements Committee
ANSI - American National Standarts Institute 
трехуровневая архитектура СУБД: 
1)Внешний (пользовательский)
2)Промежуточный (концептуальный)
3)Внутренний (физический)
В основе архитектуры ANSI/SPARC лежит концептуальный уровень. Этот уровень описывает данные и их взаимосвязи с наиболее общей точки зрения - концепции разработчиков бд. 
Внутренний уровень позволяет скрыть подробности физического хранения данных (носители, файлы... ) от концептуального уровня. 
Отделение внутреннего от концептуального уровня обеспечивает физическую независимость данных. 
На внешнем уровне описываются различные подмножества элементов концептуального уровня для представления данных различными пользователями и (или) их программами. Каждый пользователь получает в свое распоряжение часть представлений о данных, но полная концепция скрыта. 
Отделение внешнего уровня от концептуального уровня обеспечивает логическую независимость данных. 

=====Уровни моделей данных===== 
1)Предметная область
(Часть реального мира, данные о которой необходимо разместить в бд. Например: библиотека, учебный процесс в университете, магазин и тп...)
⬇️⬇️⬇️⬇️
2)Внешний (Пользовательский) уровень
(Индивидуальные представления предметной области отдельными пользователями базы данных, выполненные с помощью текста, графики и других, понятных всем средств)
⬇️⬇️⬇️⬇️
3)Концептуальный (инфологический) уровень
(Обобщенное представление всех пользователей и приложений базы данных, как правило, выполненное с использованием ER-модели "сущность-связь" (Entity-Relationship))
⬇️⬇️⬇️⬇️
4)Внутренний уровень 
(Описание желаемого способа организации базы данных в среде хранения выбранной СУБД - описание физической реализации, позволяющей добиться оптимальной производительности СУБД и обеспечения экономного использования запоминающих устройств)

Архитектура ANSI-SPARC (American National Standards Institute - Standards Planning and Requirements Committee) является концептуальной моделью управления данными, разработанной в 1975 году комитетом ANSI. Эта модель предлагает структуру для создания и управления базами данных с точки зрения их функциональности и организации.

Основные идеи, закладываемые в архитектуру ANSI-SPARC, включают:

1. Трехуровневая архитектура: ANSI-SPARC предлагает концепцию трех уровней абстракции:
   - Внешний уровень (уровень зрения пользователя): отображает данные так, чтобы пользователь мог видеть их в понятной для себя форме без деталей реализации.
   - Концептуальный уровень: описывает структуру всей базы данных в независимой от конкретной реализации форме.
   - Внутренний уровень (физический уровень): определяет физическую структуру и способы хранения данных.

2. Четкое разделение данных и обработки: ANSI-SPARC подчеркивает важность разделения данных и процессов об	работки данных, что способствует независимости анализа данных от приложений.

3. Устойчивость к изменениям и независимость: эта архитектура способствует упрощению изменений в базе данных, так как изменения на одном уровне не должны сильно влиять на другие уровни.

4. Поддержка концепции неизменности данных (Data Independence): означает, что изменения в структуре или способе хранения данных на одном уровне не должны затрагивать другие уровни.

Архитектура ANSI-SPARC стала основой для многих современных баз данных и помогла разработать принципы, которые сегодня представлены в реляционных и других базах данных.

=====ИНФОЛОГИЧЕСКАЯ МОДЕЛЬ ДАННЫХ "сущность-связь"=====
Основными конструктивными элементами инфологических моделей являются сущности, связи между ними и их свойства (атрибуты).
-------------------------------------------------------------------------------
Сущность — любой различимый объект, факт, явление, событие, идея или предмет, информацию о котором необходимо хранить в базе данных. 
Сущностями могут быть люди, места, самолеты, рейсы, вкус, цвет, женитьба, гроза, изобретение, боль и т. п. 
Необходимо различать такие понятия, как тип сущности и экземпляр сущности. 
Понятие тип сущности относится к набору однородных личностей, предметов, событий или идей, выступающих как целое. Экземпляр сущности относится к конкретной вещи в наборе. 
Например, типом сущности может быть ГОРОД, а экземпляром — Москва, Киев и т. д.
-------------------------------------------------------------------------------
Атрибут — поименованная характеристика (свойство) сущности. Это любая деталь, которая служит для уточнения, идентификации, классификации, числовой характеристики или выражения состояния сущности. 
Наименование атрибута должно быть уникальным для конкретного типа сущности, но может быть одинаковым для различного типа сущностей, например, ЦВЕТ может быть определен для многих сущностей: СОБАКА, АВТОМОБИЛЬ, ДЫМ и т. д. 
Атрибуты используются для определения того, какая информация должна быть собрана о сущности. 
Примерами атрибутов для сущности АВТОМОБИЛЬ являются ТИП, МАРКА, НОМЕРНОЙ ЗНАК, ЦВЕТ и т. д. Здесь также существует различие между типом и экземпляром. 
Тип атрибута ЦВЕТ имеет много экземпляров или значений (Красный, Синий, Банановый, Белая ночь и т. д.), однако каждому экземпляру сущности присваивается только одно значение атрибута.

Абсолютное различие между типами сущностей и атрибутами отсутствует. Атрибут является таковым только в связи с типом сущности. В другом контексте атрибут может выступать как самостоятельная сущность. Например, в расписании движения самолетов (см. рис. 1.1) город — это атрибут расписания, а в кодификаторе адресов город — тип сущности.
-------------------------------------------------------------------------------
Ключ — минимальный набор атрибутов, по значениям которых можно однозначно найти требуемый экземпляр сущности. Минимальность означает, что исключение из набора любого атрибута не позволяет идентифицировать сущность по оставшимся. Для сущности Расписание (см. разд. 1.2) ключом является атрибут Номер_рейса или набор: Пункт_отправления, Время_вылета
и Пункт_назначения (при условии, что из пункта в пункт вылетает в каждый момент времени один самолет).
Связь — ассоциирование двух или более сущностей. Абсолютное различие между типами сущностей и связями отсутствует. 
-------------------------------------------------------------------------------

=====КЛАССИФИКАЦИЯ СУЩНОСТЕЙ=====
Стержневая сущность (стержень) — это независимая сущность, которая не является ни характеристикой, ни ассоциацией. 
Ассоциативная сущность (ассоциация) — это связь вида "многие-ко-многим" ("*-ко-многим" и т. д.) между двумя или более сущностями или экземплярами сущности. Ассоциации рассматриваются как полноправные сущности:
они могут участвовать в других ассоциациях точно так же, как стержневые сущности;
могут обладать свойствами, т. е. иметь не только набор ключевых атрибутов, необходимых для указания связей, но и любое число других атрибутов, характеризующих связь.
а также уточняющие атрибуты
Характеристическая сущность (характеристика) — это связь вида "многие-к-одной" или "одна-к-одной" между двумя сущностями (частный случай ассоциации). Единственная цель характеристики в рамках рассматриваемой предметной области состоит в описании или уточнении некоторой другой сущности. Необходимость в них возникает в связи с тем, что сущности реального мира имеют иногда многозначные свойства. Муж может иметь несколько жен; книга — несколько характеристик переиздания (исправленное, дополненное, переработанное и пр.) и т. д. Существование характеристики полностью зависит от характеризуемой сущности: женщины лишаются статуса жен, если умирает их муж.

=====DDL=====
DDL (Data Definition Language) - это подмножество языка SQL (Structured Query Language), используемое для определения структуры базы данных и ее объектов, таких как таблицы, представления, индексы и процедуры. DDL Операторы используются для создания, изменения и удаления объектов базы данных, включая таблицы, представления, индексы и хранимые процедуры. Некоторые из наиболее распространенных DDL операторы включают:

CREATE: Этот оператор создает новый объект базы данных, такой как таблица, представление или индекс. Например, следующий оператор SQL создает таблицу "customers":
CREATE TABLE customers (id INT PRIMARY KEY, name VARCHAR(255), address VARCHAR(255));

ALTER: Этот оператор используется для изменения существующего объекта базы данных. Например, следующий оператор SQL добавляет новый столбец "email" в таблицу "customers":
ALTER TABLE customers ADD email VARCHAR(255);

DROP: Этот оператор используется для удаления существующего объекта базы данных. Например, следующий оператор SQL удаляет таблицу "customers":
DROP TABLE customers;

TRUNCATE: Этот оператор используется для удаления всех строк в таблице, но в отличие от оператора DROP он сохраняет структуру таблицы и индексы.
RENAME: Этот оператор используется для переименования существующего объекта базы данных. Например, следующий оператор SQL переименовывает таблицу "customers" в "clients":
RENAME TABLE customers TO clients;

Важно отметить, что DDL операторы выполняются немедленно и являются постоянными, то есть после создания, изменения или удаления объекта изменения невозможно отменить. Поэтому необходимо быть осторожным и убедиться, что у вас есть резервная копия базы данных перед выполнением любых DDL операторов. Кроме того, DDL операторы обычно выполняются администратором базы данных или разработчиком с соответствующими привилегиями и разрешениями на изменение структуры базы данных.


=====DML=====
DML (Data Manipulation Language) - это подмножество языка SQL (язык структурированных запросов), который используется для манипулирования данными в базе данных. DML Операторы используются для вставки, обновления и удаления данных в базе данных. Некоторые из наиболее распространенных DML операторы включают:

SELECT: Этот оператор используется для получения данных из одной или нескольких таблиц базы данных. Например, следующий SQL-запрос извлекает все записи из таблицы "customers":
SELECT * FROM customers;

INSERT: Этот оператор используется для вставки новых данных в таблицу. В качестве примера, следующий оператор SQL вставляет новую строку в таблицу "customers":
INSERT INTO customers (id, name, address) VALUES (1, 'John Smith,' '123 Main St');

UPDATE: Этот оператор используется для изменения существующих данных в таблице. Например, следующий оператор SQL обновляет адрес клиента с идентификатором 1 в таблице "customers":
UPDATE customers SET address = '456 Park Ave' WHERE id = 1;

DELETE: Этот оператор используется для удаления данных из таблицы. Например, следующий оператор SQL удаляет клиента с идентификатором 1 из таблицы "customers":
DELETE FROM customers WHERE id = 1;

DML Операторы выполняются немедленно и могут быть отменены с помощью оператора отката. Важно отметить, что хотя DDL операторы используются для создания, изменения и удаления объектов базы данных, DML операторы используются для манипулирования данными внутри этих объектов.

DML Операторы обычно выполняются конечными пользователями, например, приложениями или системами, взаимодействующими с базой данных для получения, обновления или удаления данных. Система управления базой данных запускает DML операторы после выполнения запроса.

язык DML содержит следующие конструкции: 
	1)SELECT - выборка данных 
	2)INSERT - вставка новых данных
	3)UPDATE - обновление данных  
	4)DELETE - удаление данных 
	5)MERGE - слияние данных
	
1)SELECT[DISTINCT - отброс строк дубликатов] список_столбцов или * 
FROM источник 
WHERE фильтр 
ORDER BY выражение_сортировки




========================
|			     	   |	
|ЛАБОРАТОРНАЯ РАБОТА №2|
|			     	   |
========================
Табличное выражение вычисляет таблицу. Это выражение содержит предложение FROM, за которым могут следовать предложения WHERE, GROUP BY и HAVING. Тривиальные табличные выражения просто ссылаются на физическую таблицу, её называют также базовой, но в более сложных выражениях такие таблицы можно преобразовывать и комбинировать самыми разными способами.

Необязательные предложения WHERE, GROUP BY и HAVING в табличном выражении определяют последовательность преобразований, осуществляемых с данными таблицы, полученной в предложении FROM. В результате этих преобразований образуется виртуальная таблица, строки которой передаются списку выборки, вычисляющему выходные строки запроса.

=====Предложение FROM=====
Предложение FROM образует таблицу из одной или нескольких ссылок на таблицы, разделённых запятыми.

FROM табличная_ссылка [, табличная_ссылка [, ...]]

Здесь табличной ссылкой может быть имя таблицы (возможно, с именем схемы), производная таблица, например подзапрос, соединение таблиц или сложная комбинация этих вариантов. Если в предложении FROM перечисляются несколько ссылок, для них применяется перекрёстное соединение (то есть декартово произведение их строк; см. ниже). Список FROM преобразуется в промежуточную виртуальную таблицу, которая может пройти через преобразования WHERE, GROUP BY и HAVING, и в итоге определит результат табличного выражения.

Когда в табличной ссылке указывается таблица, являющаяся родительской в иерархии наследования, в результате будут получены строки не только этой таблицы, но и всех её дочерних таблиц. Чтобы выбрать строки только одной родительской таблицы, перед её именем нужно добавить ключевое слово ONLY. Учтите, что при этом будут получены только столбцы указанной таблицы — дополнительные столбцы дочерних таблиц не попадут в результат.

Если же вы не добавляете ONLY перед именем таблицы, вы можете дописать после него *, тем самым указав, что должны обрабатываться и все дочерние таблицы. Добавлять * не обязательно, так как теперь это поведение подразумевается по умолчанию (если только вы не измените параметр конфигурации sql_inheritance). Однако такая запись может быть полезна тем, что подчеркнёт использование дополнительных таблиц.


=====Соединение таблиц JOIN=====
Соединённая таблица ­­­­­­— это таблица, полученная из двух других (реальных или производных от них) таблиц в соответствии с правилами соединения конкретного типа. Общий синтаксис описания соединённой таблицы:
	T1 тип_соединения T2 [ условие_соединения ]
Соединения любых типов могут вкладываются друг в друга или объединяться: и T1, и T2 могут быть результатами соединения. Для однозначного определения порядка соединений предложения JOIN можно заключать в скобки. Если скобки отсутствуют, предложения JOIN обрабатываются слева направо.

===ТИПЫ СОЕДИНЕНИЙ===
1)Перекрестное соединение 
T1 CROSS JOIN T2
Соединённую таблицу образуют все возможные сочетания строк из T1 и T2 (т. е. их декартово произведение), а набор её столбцов объединяет в себе столбцы T1 со следующими за ними столбцами T2. Если таблицы содержат N и M строк, соединённая таблица будет содержать N * M строк.

FROM T1 CROSS JOIN T2 равнозначно FROM T1 INNER JOIN T2 ON TRUE (см. ниже). Эта запись также равнозначна FROM T1, T2.

2)Соединения с сопоставлениями строк

T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2
  ON логическое_выражение
T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2
  USING ( список столбцов соединения )
T1 NATURAL { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2

Слова INNER и OUTER необязательны во всех формах. По умолчанию подразумевается INNER (внутреннее соединение), а при указании LEFT, RIGHT и FULL — внешнее соединение.

Условие соединения указывается в предложении ON или USING, либо неявно задаётся ключевым словом NATURAL. Это условие определяет, какие строки двух исходных таблиц считаются «соответствующими» друг другу. 
INNER JOIN
Для каждой строки R1 из T1 в результирующей таблице содержится строка для каждой строки в T2, удовлетворяющей условию соединения с R1.

LEFT OUTER JOIN
Сначала выполняется внутреннее соединение (INNER JOIN). Затем в результат добавляются все строки из T1, которым не соответствуют никакие строки в T2, а вместо значений столбцов T2 вставляются NULL. Таким образом, в результирующей таблице всегда будет минимум одна строка для каждой строки из T1.

RIGHT OUTER JOIN
Сначала выполняется внутреннее соединение (INNER JOIN). Затем в результат добавляются все строки из T2, которым не соответствуют никакие строки в T1, а вместо значений столбцов T1 вставляются NULL. Это соединение является обратным к левому (LEFT JOIN): в результирующей таблице всегда будет минимум одна строка для каждой строки из T2.

FULL OUTER JOIN
Сначала выполняется внутреннее соединение. Затем в результат добавляются все строки из T1, которым не соответствуют никакие строки в T2, а вместо значений столбцов T2 вставляются NULL. И наконец, в результат включаются все строки из T2, которым не соответствуют никакие строки в T1, а вместо значений столбцов T1 вставляются NULL.


========================
|			     	   |	
|ЛАБОРАТОРНАЯ РАБОТА №3|
|			     	   |
========================

Нормализация - это процесс удаления избыточных данных
Нормализация - это метод проектирования бд, который позволяет привести БД к минимальной избыточности. Избыточность обычно устраняется засчет декомпозиции отношений. 

Зачем она нужна? 
Избыточность данных создает предпосылки для появления различных аномалий, снижает производительность, и делает управление данных негибким и неудобным.

Нормализация нужна: 
	-Устранение аномалий 
	-Повышение производительности
	-Повышение удобства управления данными. 

Избыточность данных - одни и те же данные хранятся в нескольких местах базы, это и приводит к аномалии

Декомпозиция - это процесс разбиения одного отношения(таблицы) на несколько. 

=====Функциональные зависимости=====
Функциональные зависимости — это ключевое понятие в теории нормализации баз данных, описывающее отношения между атрибутами (столбцами) в отношении (таблице). Понимание различных видов функциональных зависимостей помогает в проектировании структуры баз данных таким образом, чтобы минимизировать избыточность данных и улучшить целостность данных. Вот основные виды функциональных зависимостей:

1. Простая функциональная зависимость
Простая функциональная зависимость описывает отношение между двумя атрибутами, при котором один атрибут (X) однозначно определяет другой атрибут (Y). Это обозначается как X → Y. Если зная значение X, мы всегда можем определить значение Y, то говорят, что Y функционально зависит от X.

2. Полная функциональная зависимость
Полная функциональная зависимость — это разновидность функциональной зависимости, при которой Y функционально зависит от всего составного ключа X и не может быть определена только по части этого ключа. Если X является составным ключом (например, X = {A, B}), то Y полностью функционально зависит от X (обозначается как {A, B} → Y), если она не зависит ни от A, ни от B по отдельности.

3. Частичная функциональная зависимость
Частичная функциональная зависимость возникает, когда неключевой атрибут зависит только от части составного первичного ключа. Это означает, что атрибут Y зависит от части составного ключа X, а не от всего ключа в целом. Частичная функциональная зависимость указывает на то, что нормализация до второй нормальной формы (2NF) не завершена.

4. Транзитивная функциональная зависимость
Транзитивная функциональная зависимость описывает отношение между тремя атрибутами (X, Y и Z), при котором если X функционально определяет Y, и Y функционально определяет Z, то Z транзитивно зависит от X через Y. Это обозначается как X → Y и Y → Z, следовательно, X → Z. Транзитивные зависимости нужно устранить для достижения третьей нормальной формы (3NF).

5. Многозначная зависимость
Многозначная зависимость — это более сложный тип зависимости, который используется при переходе к четвертой нормальной форме (4NF). Она существует, когда два атрибута (Y и Z) независимо зависят от X, и знание X позволяет однозначно определить множества значений Y и Z, но Y и Z не зависят друг от друга.

Различные типы функциональных зависимостей играют ключевую роль в процессе нормализации баз данных, позволяя устранять избыточность, упрощать структуру данных и повышать её качество.


=====Нормальные формы=====
Процесс нормализации: 
Следуя опереденным правилом и соблюдая определенные требования, проектируем таблицы в бд. Правила группируются в наборы, и если база соответствует опеределенному набору правил, то она находится в нормальной форме

Нормальная форма бд - это набор правил и критериев, которым должна отвечать бд. 

Процесс нормализации - это последовательный процесс приведения бд к эталонному виду (переход от 1 нормальной формы к следующей)

Денормализация- это не результат кривых рук. Это не недоделанная нормализация, это намеренное нарушение нормальных форм, для увеличения производительности.
Когда нужна денормализация?
	1)Большое количество соединений.  
	2)Расчетные значения.
	3)Длинные поля. 
	4)Частота запросов и устойчивость производительности.

Основные нормальные формы: 
	-Первая нф(1NF)
	-Вторая нф(2NF)
	-Третья нф(3NF)
	-четвертая нф(4NF)
	-пятая нф(5NF)
	
Дополнительные нормальные формы: 
	-Ненормальная форма или нулевая нормальная форма (UNF): 
		
	-Нормальная форма Бойса - Кодда(BCNF)
	-Доменно-ключевая нф (DKNF)
	-Шестая нормальная форма (6NF)

Полный порядок: 
	1)UNF
	2)1NF 
	3)2NF
	4)3NF 
	5)BCNF 
	6)4NF 
	7)5NF 
	8)DKNF
	9)6NF

БД считается нормализованной, если находится как минимум в 3NF.
Последние 3 формы являются больше теоретической частью, так как сложно даже представить такую таблицу, которой потребуется такая нормализация. 

Приведение к новой нормальной форме обязует бд находится в предыдущей нормальной форме. 

1)ПЕРВАЯ НОРМАЛЬНАЯ ФОРМА(1NF)
Таблицы должны соответствовать реляционной модели данных и соблюдать опеределенные реляционные принципы: 
	-Не должно быть дублирующих строк 
	-В каждой ячейке таблицы хранится атомарное значение(одно не составное значение)
	-В столбце хранятся данные одного типа 
	-Отсутствуют массивы и списки в любом виде
Описать первую НФ можно примерно так: 
	+Назначение строк - хранить значения 
	+Назначение столбцов - хранить структурную информацию
	+Назначение ячеек - хранить атомарное значение. 

Если таблица создана с соблюдением всех реляционных принципов, значит, она уже находится в первой НФ. 

2)ВТОРАЯ НОРМАЛЬНАЯ ФОРМА(2NF)
Необходимые требования: 
	-Таблица находится в 1NF
	-Таблица должна иметь ключ 
	-Все неключевые столбцы должны зависеть от полного ключа(в случае, если ключ составной)
Основное правило: таблица должна иметь правильный ключ, по которому можно идентифицировать каждую строку. 


3)ТРЕТЬЯ НОРМАЛЬНАЯ ФОРМА(3NF)

В таблицах должна отсутствовать транзитивная зависимость. 
Транзитивная зависимость - это когда неключевые столбцы зависят от значений других неключевых столбцов

Неключевые столбцы не должны пытаться играть роль ключа в таблице. 

Таблица должна содержать правильные неключевые столбцы.

4)НОРМАЛЬНАЯ ФОРМА БОЙСА-КОДДА (BCNF) или можно сказать усиленная форма Бойса - Кодда
Требования: 
	-Таблица должна находиться в 3NF 
	-Ключевые атрибуты составного ключа не должны зависеть от неключевых атрибутов. 
Требования BCNF актуальны только для таблиц с составными ключами. 

Основное правило:
	Часть составного первичного ключа не должна зависеть от неключевого столбца

В таблицах, где ключ простой и находятся в 3NF автоматически находятся в BCNF

5)ЧЕТВЕРТАЯ НОРМАЛЬНАЯ ФОРМА (4NF):
Требования: 
	-Таблица должна находиться в 3NF
	-В таблицах должны отсутствовать нетривиальные многозначные зависимости. 

Пример зависимости: 
	Есть таблица со столбцами A, B и C. При этом B и C никак не связаны между собой, но по отдельности они зависят от A, и для каждого значения A есть множество значений B и множество значений C 
	A -> B
	A -> C
Если в таблице есть такая многозначная зависимость, то она не соответствует 4NF

4NF необходима, если мы хотим внести изменения в одну зависимость, мы неизбежно внесем её в другую. 

Основное правило:
	В таблице не должно быть многозадачных зависимостей. 

6)Пятая Нормальная Форма (5NF)
Требования: 
	-Переменная находится в 5NF (проекционно - соединительной нф), когда каждая нетривиальная зависимость соединений в ней определяется потенциальным ключом (ключами) этого отношения
	
Есть таблицы, которые при декомпозиции на 2 таблицы могут потерять некоторые данные, но при декомпозиции на 3 таблицы потери данных можно избежать. 
То есть при join будет получена та же таблица, что и до декомпозиции на 3 таблицы.(не будет содержать зависимости соединений)
Декомпозиция без потерь - процесс разбиения одной таблицы на несколько, при условии, что в случае соединения таблиц, которые были получены в результате декомпозиции, будет формироваться та же информация, что и в исходной таблице до декомпозиции. 

Получается, чтобы выполнить требования  5NF, нужно осуществить декомпозицию таблиц без потери данных. 
Пример: 
Сотрудник		Проект				Направление
Иванов			Интернет-магазин	Разработка 
Сергеев			Новый офис			Бухгалтер 
Иванов			Личный кабинет		Разработка
и тд и тп.... 



7)Шестая нормальная форма(6NF)
6NF — это концепция, предложенная для дальнейшего улучшения структурирования данных, особенно в контексте временных баз данных, где требования к информации могут меняться со временем. База данных находится в 6NF, если она находится в 5NF и содержит только один-элементные (одностолбцовые) ключи как способ дальнейшего уменьшения избыточности и упрощения структуры базы данных. 6NF часто рассматривается как теоретически идеальная форма, редко применяемая на практике из-за её строгости и сложности реализации.



8)Доменно-Ключевая Нормальная Форма (DKNF)
База данных находится в DKNF, если каждое ограничение на данные является логическим следствием определений её доменов и ключей. DKNF считается конечной целью в процессе нормализации, поскольку она устраняет все виды избыточности и аномалий вставки/обновления/удаления. Достичь DKNF означает, что база данных полностью нормализована в соответствии с всеми её ключами и доменными ограничениями, и больше нет необходимости в дальнейшей декомпозиции




9)




Почему обычно не нормализуют базу до 5 и 6 нормальной формы, ведь тогда не будет аномалий и всё будет чики пуки. 

Устарение аномалий повышает производительность, но только где то до 3NF. Начиная с 4NF производительность будет снижаться из за увеличения количества таблиц, а также работать с такой бд неудобно. 
В процессе проектирования БД нужно найти баланс между отсутствием аномалий и приемлемой производительностью. 
Полностью нормализированная БД = Плохая БД
Хорошая БД - база, которая достаточно нормализирована, чтобы не создавать аномалии для пользователей, и одновременно имеет хорошую производительность. 


=====PL/pgSQL=====

Функции и триггеры в системах управления базами данных (СУБД), таких как PostgreSQL, являются мощными инструментами для автоматизации и управления данными. Они позволяют реализовывать сложную логику обработки данных и обеспечивают механизмы для реагирования на различные события в базе данных.

Функции
Функции в базах данных — это подпрограммы, которые могут принимать параметры, выполнять операции (например, вычисления, обработку данных, логические операции) и возвращать результат. Функции могут быть использованы в SQL-запросах, триггерах и других функциях.

Особенности функций:

Параметры: Функции могут принимать ноль или более параметров.
Возвращаемый тип: Функции могут возвращать значение определенного типа или не возвращать его вовсе (VOID).
Языки программирования: Функции могут быть написаны на различных языках, включая SQL, PL/pgSQL (для PostgreSQL), PL/SQL (для Oracle), и даже на внешних языках, таких как Python или C, при поддержке соответствующей СУБД.
Применение: Функции могут использоваться для реализации бизнес-логики, агрегации данных, выполнения регулярных задач обработки данных и многого другого.
Триггеры
Триггеры — это специальные процедуры, которые автоматически выполняются (срабатывают) в ответ на определенные события в базе данных, такие как вставка, обновление или удаление записей.

Особенности триггеров:

События: Триггеры могут срабатывать на операции INSERT, UPDATE, DELETE и иногда TRUNCATE.
Уровень срабатывания: Триггеры могут быть настроены для срабатывания по каждой модифицированной строке (FOR EACH ROW) или один раз на операцию (FOR EACH STATEMENT), независимо от количества затронутых строк.
Время срабатывания: Триггеры могут быть настроены для выполнения до (BEFORE) или после (AFTER) события, а также вместо (INSTEAD OF) события (обычно для представлений).
Триггерные функции: Триггеры вызывают определенные функции, которые содержат логику, выполняемую при срабатывании триггера.
------------------------------------------------------------

PostgreSQL позволяет разрабатывать пользовательские функции не только на SQL и C, но и на других языках. Эти языки в целом называются процедурными языками (PL, Procedural Language). Если функция написана на процедурном языке, сервер баз данных сам по себе не знает, как интерпретировать её исходный текст. Вместо этого он передаёт эту задачу специальному обработчику, понимающему данный язык. Обработчик может либо выполнить всю работу по разбору, синтаксическому анализу, выполнению кода и т. д., либо действовать как "прослойка" между PostgreSQL и внешним исполнителем языка программирования. Сам обработчик представляет собой функцию на языке C, скомпилированную в виде разделяемого объекта и загружаемую по требованию, как и любая другая функция на C.

PL/pgSQL это процедурный язык для СУБД PostgreSQL. Целью проектирования PL/pgSQL было создание загружаемого процедурного языка, который:
	-используется для создания функций и триггеров,
	-добавляет управляющие структуры к языку SQL,
	-может выполнять сложные вычисления,
	-наследует все пользовательские типы, функции и операторы,
	-может быть определён как доверенный язык,
	-прост в использовании
	
Функции PL/pgSQL могут использоваться везде, где допустимы встроенные функции. Например, можно создать функции со сложными вычислениями и условной логикой, а затем использовать их при определении операторов или в индексных выражениях.


Функции на PL/pgSQL могут принимать в качестве аргументов все поддерживаемые сервером скалярные типы данных или массивы и возвращать в качестве результата любой из этих типов. Они могут принимать и возвращать именованные составные типы (строковый тип). Также есть возможность объявить функцию на PL/pgSQL, возвращающую record, это означает, что результатом является строковый тип, чьи столбцы будут определены в спецификации вызывающего запроса

Использование маркера VARIADIC позволяет объявлять функции на PL/pgSQL с переменным числом аргументов. Это работает точно так же, как и для функций на SQL

Функции на PL/pgSQL могут принимать и возвращать полиморфные типы anyelement, anyarray, anynonarray, anyenum и anyrange. В таких случаях фактические типы данных могут меняться от вызова к вызову

Функции на PL/pgSQL могут возвращать "множества" (или таблицы) любого типа, которые могут быть возвращены в виде одного объекта. Такие функции генерируют вывод, выполняя команду RETURN NEXT для каждого элемента результирующего набора или RETURN QUERY для вывода результата запроса.

Наконец, при отсутствии полезного возвращаемого значения функция на PL/pgSQL может возвращать void.

Функции на PL/pgSQL можно объявить с выходными параметрами вместо явного задания типа возвращаемого значения. Это не добавляет никаких фундаментальных возможностей языку, но часто бывает удобно, особенно для возвращения нескольких значений. Нотация RETURNS TABLE может использоваться вместо RETURNS SETOF.

PL/pgSQL это блочно-структурированный язык. Текст определения функции должен быть блоком. Структура блока:

[<<метка>>]
[ DECLARE 
	объявление ] 
BEGIN 
	операторы
END [метка];

Метка требуется только тогда, когда нужно идентифицировать блок в операторе EXIT, или дополнить имена переменных, объявленных в этом блоке. Если метка указана после END, то она должна совпадать с меткой в начале блока.

Любой оператор в выполняемой секции блока может быть вложенным блоком. Вложенные блоки используются для логической группировки нескольких операторов или локализации области действия переменных для группы операторов. Во время выполнения вложенного блока переменные, объявленные в нём, скрывают переменные внешних блоков с такими же именами. Чтобы получить доступ к внешним переменным, нужно дополнить их имена меткой блока. Например:

CREATE FUNCTION somefunc() RETURNS integer AS $$
<< outerblock >>
DECLARE
    quantity integer := 30;
BEGIN
    RAISE NOTICE 'Сейчас quantity = %', quantity;  -- Выводится 30
    quantity := 50;
    --
    -- Создаем вложенный блок
    --
    DECLARE
        quantity integer := 80;
    BEGIN
        RAISE NOTICE 'Сейчас quantity = %', quantity;  -- Выводится 80
        RAISE NOTICE 'Во внешнем блоке quantity = %', outerblock.quantity;  -- Выводится 50
    END;

    RAISE NOTICE 'Сейчас quantity = %', quantity;  -- Выводится 50

    RETURN quantity;
END;
$$ LANGUAGE plpgsql;		

Все переменные, используемые в блоке, должны быть определены в секции объявления. (За исключением переменной-счётчика цикла FOR, которая объявляется автоматически. Для цикла по диапазону чисел автоматически объявляется целочисленная переменная, а для цикла по результатам курсора - переменная типа record.)

Переменные PL/pgSQL могут иметь любой тип данных SQL, такой как integer, varchar, char.

Примеры объявления переменных:

user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;


Общий синтаксис объявления переменной:
name [ CONSTANT ] type [ COLLATE collation_name ] [ NOT NULL ] [ { DEFAULT | := | = } expression ];

Предложение DEFAULT, если присутствует, задаёт начальное значение, которое присваивается переменной при входе в блок. Если отсутствует, то переменная инициализируется SQL значением NULL. Указание CONSTANT предотвращает изменение значения переменной после инициализации, таким образом, значение остаётся постоянным в течение всего блока. Параметр COLLATE определяет правило сортировки, которое будет использоваться для этой переменной (см. Подраздел 40.3.6). Если указано NOT NULL, то попытка присвоить NULL во время выполнения приведёт к ошибке. Все переменные, объявленные как NOT NULL, должны иметь непустые значения по умолчанию. Можно использовать знак равенства (=) вместо совместимого с PL/SQL :=.

Значение по умолчанию вычисляется и присваивается переменной каждый раз при входе в блок (не только при первом вызове функции). Так, например, если переменная типа timestamp имеет функцию now() в качестве значения по умолчанию, это приведёт к тому, что переменная всегда будет содержать время текущего вызова функции, а не время, когда функция была предварительно скомпилирована.

Примеры:

quantity integer DEFAULT 32;
url varchar := 'http://mysite.com' 
user_id CONSTANT integer := 10;

Можно указывать выходные параметры, особенно это необходимо когда возвращаются несколько значений
CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
BEGIN
    tax := subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;

Есть ещё способ объявить функцию на PL/pgSQL с использованием RETURNS TABLE, например:
CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS $$
BEGIN
    RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales s
                 WHERE s.itemno = p_itemno;
END;
$$ LANGUAGE plpgsql;
------------------------------------
newname ALIAS FOR oldname;
Синтаксис ALIAS более общий, чем предполагалось в предыдущем разделе: псевдонимы можно объявлять для любых переменных, а не только для параметров функции. Основная практическая польза в том, чтобы назначить другие имена переменным с предопределёнными названиями, таким как NEW или OLD в триггерной процедуре.

Примеры:

DECLARE
  prior ALIAS FOR old;
  updated ALIAS FOR new;
Поскольку ALIAS даёт два различных способа именования одних и тех же объектов, то его неограниченное использование может привести к путанице. Лучше всего использовать ALIAS для переименования предопределённых имён.

---------------------------------------
variable%TYPE
Конструкция %TYPE предоставляет тип данных переменной или столбца таблицы. Её можно использовать для объявления переменных, содержащих значения из базы данных. Например, для объявления переменной с таким же типом, как и столбец user_id в таблице users нужно написать:

user_id users.user_id%TYPE;
Используя %TYPE не нужно знать тип данных структуры, на которую ссылаетесь. И самое главное, если в будущем тип данных изменится (например: тип данных для user_id поменяется с integer на real), то вам может не понадобиться изменять определение функции.

Использование %TYPE особенно полезно в полиморфных функциях, поскольку типы данных, необходимые для внутренних переменных, могут меняться от одного вызова к другому. Соответствующие переменные могут быть созданы с применением %TYPE к аргументам и возвращаемому значению функции.
--------------------------------------------
имя table_name%ROWTYPE;
имя composite_type_name;
Переменная составного типа называется строковой (row) переменной или переменной строкового типа (row-type). Значением такой переменной может быть целая строка, полученная в результате выполнения запроса SELECT или FOR, при условии, что набор столбцов запроса соответствует заявленному типу переменной. Доступ к отдельным значениям полей строковой переменной осуществляется, как обычно, через точку, например rowvar.field.

Строковая переменная может быть объявлена с таким же типом, как и строка в существующей таблице или представлении, используя нотацию table_name%ROWTYPE; или при объявлении указывается имя составного типа. (Поскольку каждая таблица имеет соответствующий составной тип с таким же именем, то на самом деле, в PostgreSQL не имеет значения, пишете ли вы %ROWTYPE или нет. Но использование %ROWTYPE более переносимо.)

CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$
DECLARE
    t2_row table2%ROWTYPE;
BEGIN
    SELECT * INTO t2_row FROM table2 WHERE ... ;
    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM table1 t WHERE ... ;
-------------------------------------------------------------
имя RECORD;
Переменные типа record похожи на переменные строкового типа, но они не имеют предопределённой структуры. Они приобретают фактическую структуру от строки, которая им присваивается командами SELECT или FOR. Структура переменной типа record может меняться каждый раз при присвоении значения. Следствием этого является то, что пока значение не присвоено первый раз, переменная типа record не имеет структуры и любая попытка получить доступ к отдельному полю приведёт к ошибке во время исполнения.

Обратите внимание, что RECORD это не подлинный тип данных, а только лишь заполнитель. Также следует понимать, что функция на PL/pgSQL, имеющая тип возвращаемого значения record, это не то же самое, что и переменная типа record, хотя такая функция может использовать переменную типа record для хранения своего результата. В обоих случаях фактическая структура строки неизвестна во время создания функции, но для функции, возвращающей record, фактическая структура определяется во время разбора вызывающего запроса, в то время как переменная типа record может менять свою структуру на лету.

Триггеры используют для того, чтобы сказать движку PostgreSQL выполнить часть кода при наступлении определённого события. Получается своего рода катализатор изменений, спусковой крючок, который запускает цепь событий.

Триггер должен быть связан с указанной таблицей, представлением (псевдотаблицей) или внешней таблицей. Он запускает свою часть кода только при выполнении операций с этой сущностью — INSERT, UPDATE, DELETE или TRUNCATE. В зависимости от требований мы можем запускать триггер до, после или вместо события/операции.

Типы триггеров
Триггеры делятся на два типа в зависимости от того, на каком уровне они действуют.

Если триггер помечен опцией FOR EACH ROW, тогда функция вызывается для каждой строки, которая изменяется в результате события. Например, если сделать UPDATE для 100 строк, триггерная функция UPDATE будет вызываться 100 раз, по одному разу для каждой обновлённой строки.

Опция FOR EACH STATEMENT вызовет функцию только один раз для каждого оператора, независимо от количества изменяемых строк.

CREATE [ OR REPLACE ] [ CONSTRAINT ] TRIGGER name { BEFORE | AFTER | INSTEAD OF } { event [ OR ... ] }
    ON table_name
    [ FROM referenced_table_name ]
   [ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ]
    [ REFERENCING { { OLD | NEW } TABLE [ AS ] transition_relation_name } [ ... ] ]
    [ FOR [ EACH ] { ROW | STATEMENT } ]
    [ WHEN ( condition ) ]
    EXECUTE { FUNCTION | PROCEDURE } function_name ( arguments )

=====Триггерные функции=====
Триггер при изменении данных объявляется как функция без аргументов и с типом результата trigger. Заметьте, что эта функция должна объявляться без аргументов, даже если ожидается, что она будет получать аргументы, заданные в команде CREATE TRIGGER — такие аргументы передаются через TG_ARGV, как описано ниже.

Когда функция на PL/pgSQL срабатывает как триггер, в блоке верхнего уровня автоматически создаются несколько специальных переменных:

NEW
Тип данных RECORD. Переменная содержит новую строку базы данных для команд INSERT/UPDATE в триггерах уровня строки. В триггерах уровня оператора и для команды DELETE этой переменной значение не присваивается.

OLD
Тип данных RECORD. Переменная содержит старую строку базы данных для команд UPDATE/DELETE в триггерах уровня строки. В триггерах уровня оператора и для команды INSERT этой переменной значение не присваивается.

TG_NAME
Тип данных name. Переменная содержит имя сработавшего триггера.

TG_WHEN
Тип данных text. Строка, содержащая BEFORE, AFTER или INSTEAD OF, в зависимости от определения триггера.

TG_LEVEL
Тип данных text. Строка, содержащая ROW или STATEMENT, в зависимости от определения триггера.

TG_OP
Тип данных text. Строка, содержащая INSERT, UPDATE, DELETE или TRUNCATE, в зависимости от того, для какой операции сработал триггер.

TG_RELID
Тип данных oid. OID таблицы, для которой сработал триггер.

TG_RELNAME
Тип данных name. Имя таблицы, для которой сработал триггер. Эта переменная устарела и может стать недоступной в будущих релизах. Вместо неё нужно использовать TG_TABLE_NAME.

TG_TABLE_NAME
Тип данных name. Имя таблицы, для которой сработал триггер.

TG_TABLE_SCHEMA
Тип данных name. Имя схемы, содержащей таблицу, для которой сработал триггер.

TG_NARGS
Тип данных integer. Число аргументов в команде CREATE TRIGGER, которые передаются в триггерную процедуру.

TG_ARGV[]
Тип данных массив text. Аргументы от оператора CREATE TRIGGER. Индекс массива начинается с 0. Для недопустимых значений индекса ( < 0 или >= tg_nargs) возвращается NULL.



-----------------------
триггер 3лаба

CREATE OR REPLACE FUNCTION update_museum_rating()
RETURNS TRIGGER AS $$
DECLARE
    id INT;
    total_emotion_value INT;
    total_visits INT;
    new_rating FLOAT;
BEGIN
    IF TG_OP = 'DELETE' THEN
        id := OLD.museum_id;
    ELSE
        id := NEW.museum_id;
    END IF;
    
    SELECT SUM(emotion_value) INTO total_emotion_value
    FROM visits
    JOIN emotion ON visits.emotion_id = emotion.emotion_id
    WHERE id = museum_id;
    
    SELECT COUNT(*) INTO total_visits
    FROM visits
    WHERE id = museum_id;

    IF total_visits > 0 THEN
        new_rating := total_emotion_value::FLOAT / total_visits;
    ELSE
        new_rating := 0;
    END IF;

    UPDATE museum
    SET rate = new_rating
    WHERE id = museum_id;

    RETURN NULL; 
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE TRIGGER update_rating 
AFTER INSERT OR UPDATE ON visits 
FOR EACH ROW
EXECUTE FUNCTION update_museum_rating();

CREATE OR REPLACE TRIGGER update_rating_del
AFTER DELETE ON visits 
FOR EACH ROW 
EXECUTE FUNCTION update_museum_rating();


=====ЛАБОРАТОРНАЯ №4===== 
Индексы представляют собой структуры данных, которые позволяют базе данных быстрее находить и извлекать информацию.

Индексация - это что - то вроде книжного: не нужно перелистывать все страницы книги, чтобы найти нужную главу, а можно просто найти нужную страницу в содержании. 
Индексация позволяет с помощью индекса быстрее найти в бд данные по запросу. 


БД анализирует все возможные пути выполнения запроса, выбирая самый оптимальный из них. Каждый возможный путь называется ПЛАНОМ ВЫПОЛНЕНИЯ ЗАПРОСА - это последовательность операций для получения результата SQl - запроса в реляционной системе управления базами данных (СУРБД)
Компонент СУРБД, определяющий наиболее эффективный способ выполнения запроса с учётом анализа всех возможных планов называется ОПТИМИЗАТОРОМ ЗАПРОСОВ.

Когда применять индексацию? 
-Индексам необходимо место для хранения 
-При добавлении данных в БД сначала обновляется исходная таблица, а затем все её индексы 

Лучше использовать индексы для БД в хранилищах данных, получающие плановые обновления, а не для тех, которые постоянно обновляются
(при постоянных обновлениях БД индексы будут бесполезны и не будут обновляться)
Индексы работают неявно, то есть 
-При выполнении запроса СУБД определяет, какие индексы нужно использовать 
-В рамках того или иного запроса СУБД может не использовать индекс 

Индексы создаются по таблицам для ускорения операций, включающих: 
-Предложения where и join
-определение значений min() max() по индексированному столбцу
-сортировку и группировку столбцов таблицы

недостатки:
-занимает память
-необходимо обновлять при обновлении данных
-неэффективны, если мало строк
-по условию выбираются большие объемы данных

Без индексов, базе данных приходится выполнять полный сканирование таблицы (sequential scan), чтобы найти нужные данные. Это может быть медленным и ресурсоемким процессом, особенно для больших таблиц. Индексы позволяют существенно ускорить поиск, так как они предоставляют структуру данных, которая указывает на местоположение нужной информации в таблице.

Индексы: 
-Кластеризованные  
-некластеризованные 

Кластеризованный индекс использует первичный ключ для структуризации данных в таблице. Он не требует явного объявления и создается по умолчанию при определении ключа. 

Индексы используют двоичный поиск.(бинарное дерево(делим на 2 и ищем в половинках))

Некластеризованный индекс нужен, чтобы применить индексы к неключевым столбцам - такие индексы требуют явного определения. 

Некластеризованный индекс хранится в 1 месте, а физические данные таблицы - в другом.

Когда лучше не использовать индексы: 
-Индексы лучше не использовать в небольших таблицах
-В таблицах с частыми массовыми update и insert 
-Столбцы, которые часто обрабатываются, лучше не индексировать
-Индексы не должны использовать для столбцов, где есть много null значений. 
 
 

PostgreSQL поддерживает несколько типов индексов, каждый из которых предназначен для определенных задач и сценариев использования. Рассмотрим каждый из них подробнее.

=====B-tree=====
B-tree (сбалансированное дерево) — это самый распространенный тип индекса в PostgreSQL. Он поддерживает все стандартные операции сравнения (>, <, >=, <=, =, <>) и может использоваться с большинством типов данных. B-tree индексы могут быть использованы для сортировки, ограничений уникальности и поиска по диапазону значений.
Пример создания B-tree индекса:
CREATE INDEX ix_example_btree ON example_table (column_name);

=====Hash=====
Hash-индексы предназначены для обеспечения быстрого доступа к данным по равенству. Они менее эффективны, чем B-tree индексы, и не поддерживают сортировку или поиск по диапазону значений. Из-за своих ограничений, Hash-индексы редко используются на практике.
Пример создания Hash-индекса:
CREATE INDEX ix_example_hash ON example_table USING hash (column_name);

=====GiST (Generalized Search Tree)=====
GiST-индексы являются обобщенными и многоцелевыми, предназначены для работы с сложными типами данных, такими как геометрические объекты, текст и массивы. Они позволяют быстро выполнять поиск по пространственным, текстовым и иерархическим данным.
Пример создания GiST-индекса для поиска в текстовых данных:
CREATE INDEX ix_example_gist ON example_table USING gist (to_tsvector('english', column_name));

=====SP-GiST (Space-Partitioned Generalized Search Tree)=====
SP-GiST индексы предназначены для работы с непересекающимися и неравномерно распределенными данными. Они эффективны для поиска в геометрических и IP-адресных данных.
Пример создания SP-GiST индекса:
CREATE INDEX ix_example_spgist ON example_table USING spgist (inet(column_name));

=====GIN (Generalized Inverted Index)=====
GIN-индексы применяются для полнотекстового поиска и поиска по массивам, JSON и триграммам. Они обеспечивают высокую производительность при поиске в больших объемах данных.
Пример создания GIN-индекса для полнотекстового поиска:
CREATE INDEX ix_example_gin ON example_table USING gin (to_tsvector('english', column_name));

=====BRIN (Block Range INdex)=====
BRIN-индексы используются для компактного представления больших объемов данных, особенно когда значения в таблице имеют определенный порядок. Они эффективны для хранения и обработки временных рядов и географических данных.
Пример создания BRIN-индекса для временного ряда:
CREATE INDEX ix_example_brin ON example_table USING brin (column_name);
Без индексов, базе данных приходится выполнять полный сканирование таблицы (sequential scan), чтобы найти нужные данные. Это может быть медленным и ресурсоемким процессом, особенно для больших таблиц. Индексы позволяют существенно ускорить поиск, так как они предоставляют структуру данных, которая указывает на местоположение нужной информации в таблице.

Следует отметить, что индексы не всегда являются положительным фактором для производительности. При вставке, обновлении или удалении данных, индексы также должны быть обновлены, что может привести к дополнительным затратам времени и ресурсов. В связи с этим, важно тщательно анализировать и выбирать индексы, которые действительно улучшают производительность запросов и не создают лишней нагрузки на систему.
