=====(1)Многопоточность. Класс Thread, интерфейс Runnable. Модификатор synchronized.=====
Многопоточность позволяет выполнять несколько задач одновременно, повышая эффективность и отзывчивость приложений. Java предоставляет различные инструменты для реализации многопоточности, включая классы Thread и интерфейс Runnable, а также механизмы синхронизации, такие как модификатор synchronized.
Класс `Thread` представляет поток выполнения. Для создания потока можно:

1. Наследовать класс `Thread`:
    - Создайте класс, расширяющий `Thread`.
    - Переопределите метод `run()`, который содержит код, выполняемый потоком.
    - Создайте экземпляр класса и вызовите метод `start()`, чтобы запустить поток.
2. Реализовать интерфейс `Runnable`:
    - Создайте класс, реализующий интерфейс `Runnable`.
    - Реализуйте метод `run()`, который содержит код, выполняемый потоком.
    - Создайте экземпляр класса и передайте его конструктору `Thread`.
    - Вызовите метод `start()` у объекта `Thread`, чтобы запустить поток.
    
Интерфейс Runnable
Интерфейс `Runnable` предоставляет метод `run()`, который содержит код, выполняемый потоком. Реализация `Runnable` предпочтительнее наследования `Thread`, так как:

- Позволяет классу наследовать от другого класса.
- Поддерживает разделение логики потока от управления потоком.

### Модификатор synchronized

В многопоточных приложениях важно синхронизировать доступ к общим ресурсам, чтобы предотвратить состояния гонки и несогласованность данных. Модификатор `synchronized` обеспечивает взаимное исключение, позволяя только одному потоку одновременно выполнять блок кода, защищенный `synchronized`.

Существует несколько способов использования `synchronized`:

- Синхронизированные методы: объявление метода как `synchronized` обеспечивает синхронизацию всего метода.
- Синхронизированные блоки: использование блока `synchronized(object)` обеспечивает синхронизацию только части кода.
- Статические синхронизированные методы: синхронизация на уровне класса, влияющая на все экземпляры класса.

Пример использования synchronized:

public class Counter {
	private int count = 0;
	public synchronized void increment() {
			count++;
	}

	public synchronized int getCount() {
			return count;
	}
В этом примере методы increment() и getCount() объявлены как synchronized, что гарантирует, что только один поток может увеличивать счетчик или получать его значение в любой момент времени.

=====(2)Методы wait(), notify() класса Object, интерфейсы Lock и Condition.=====
Каждый объект в Java имеет ассоциированный с ним монитор. Монитор представляет своего рода инструмент для управления доступа к объекту.
Иногда при взаимодействии потоков встает вопрос о извещении одних потоков о действиях других. Например, действия одного потока зависят от результата действий другого потока, и надо как-то известить один поток, что второй поток произвел некую работу. И для подобных ситуаций у класса Object определено ряд методов:

wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()
notify(): продолжает работу потока, у которого ранее был вызван метод wait()
notifyAll(): возобновляет работу всех потоков, у которых ранее был вызван метод wait()
Все эти методы вызываются только из синхронизированного контекста - синхронизированного блока или метода.

Рассмотрим, как мы можем использовать эти методы. Возьмем стандартную задачу из прошлой темы - "Производитель-Потребитель" ("Producer-Consumer"): пока производитель не произвел продукт, потребитель не может его купить. Пусть производитель должен произвести 5 товаров, соответственно потребитель должен их все купить. Но при этом одновременно на складе может находиться не более 3 товаров. Для решения этой задачи задействуем методы wait() и notify():

public class Program {
  
    public static void main(String[] args) {
          
        Store store=new Store();
        Producer producer = new Producer(store);
        Consumer consumer = new Consumer(store);
        new Thread(producer).start();
        new Thread(consumer).start();
    }
}
// Класс Магазин, хранящий произведенные товары
class Store{
   private int product=0;
   public synchronized void get() {
      while (product<1) {
         try {
            wait();
         }
         catch (InterruptedException e) {
         }
      }
      product--;
      System.out.println("Покупатель купил 1 товар");
      System.out.println("Товаров на складе: " + product);
      notify();
   }
   public synchronized void put() {
       while (product>=3) {
         try {
            wait();
         }
         catch (InterruptedException e) { 
         } 
      }
      product++;
      System.out.println("Производитель добавил 1 товар");
      System.out.println("Товаров на складе: " + product);
      notify();
   }
}
// класс Производитель
class Producer implements Runnable{
  
    Store store;
    Producer(Store store){
       this.store=store; 
    }
    public void run(){
        for (int i = 1; i < 6; i++) {
            store.put();
        }
    }
}
// Класс Потребитель
class Consumer implements Runnable{
      
     Store store;
    Consumer(Store store){
       this.store=store; 
    }
    public void run(){
        for (int i = 1; i < 6; i++) {
            store.get();
        }
    }
}
Итак, здесь определен класс магазина, потребителя и покупателя. Производитель в методе run() добавляет в объект Store с помощью его метода put() 5 товаров. Потребитель в методе run() в цикле обращается к методу get объекта Store для получения этих товаров. Оба метода Store - put и get являются синхронизированными.

Для отслеживания наличия товаров в классе Store проверяем значение переменной product. По умолчанию товара нет, поэтому переменная равна 0. Метод get() - получение товара должен срабатывать только при наличии хотя бы одного товара. Поэтому в методе get проверяем, отсутствует ли товар:

Если товар отсутсвует, вызывается метод wait(). Этот метод освобождает монитор объекта Store и блокирует выполнение метода get, пока для этого же монитора не будет вызван метод notify().

Когда в методе put() добавляется товар и вызывается notify(), то метод get() получает монитор и выходит из конструкции while (product<1), так как товар добавлен. Затем имитируется получение покупателем товара. Для этого выводится сообщение, и уменьшается значение product: product--. И в конце вызов метода notify() дает сигнал методу put() продолжить работу.

В методе put() работает похожая логика, только теперь метод put() должен срабатывать, если в магазине не более трех товаров. Поэтому в цикле проверяется наличие товара, и если товар уже есть, то освобождаем монитор с помощью wait() и ждем вызова notify() в методе get().
----------------------------------------------------------------------------------
LOCK AND CONDITION
Для управления доступом к общему ресурсу в качестве альтернативы оператору synchronized мы можем использовать блокировки. Функциональность блокировок заключена в пакете java.util.concurrent.locks.
Вначале поток пытается получить доступ к общему ресурсу. Если он свободен, то на него накладывает блокировку. После завершения работы блокировка с общего ресурса снимается. Если же ресурс не свободен и на него уже наложена блокировка, то поток ожидает, пока эта блокировка не будет снята.
Классы блокировок реализуют интерфейс Lock, который определяет следующие методы:
void lock(): ожидает, пока не будет получена блокировка
void lockInterruptibly() throws InterruptedException: ожидает, пока не будет получена блокировка, если поток не прерван
boolean tryLock(): пытается получить блокировку, если блокировка получена, то возвращает true. Если блокировка не получена, то возвращает false. В отличие от метода lock() не ожидает получения блокировки, если она недоступна
void unlock(): снимает блокировку
Condition newCondition(): возвращает объект Condition, который связан с текущей блокировкой
Организация блокировки в общем случае довольно проста: для получения блокировки вызывается метод lock(), а после окончания работы с общими ресурсами вызывается метод unlock(), который снимает блокировку.
Объект Condition позволяет управлять блокировкой.
Как правило, для работы с блокировками используется класс ReentrantLock из пакета java.util.concurrent.locks. Данный класс реализует интерфейс Lock.



Simply put, a lock is a more flexible and sophisticated thread synchronization mechanism than the standard synchronized block.

Differences Between Lock and Synchronized Block
There are a few differences between the use of synchronized block and using Lock APIs:

A synchronizedblock is fully contained within a method. We can have Lock APIs lock() and unlock() operation in separate methods.
A synchronized block doesn’t support the fairness. Any thread can acquire the lock once released, and no preference can be specified. We can achieve fairness within the Lock APIs by specifying the fairness property. It makes sure that the longest waiting thread is given access to the lock.
A thread gets blocked if it can’t get an access to the synchronized block. The Lock API provides tryLock() method. The thread acquires lock only if it’s available and not held by any other thread. This reduces blocking time of thread waiting for the lock.
A thread that is in “waiting” state to acquire the access to synchronized block can’t be interrupted. The Lock API provides a method lockInterruptibly() that can be used to interrupt the thread when it’s waiting for the lock.

void lock() – Acquire the lock if it’s available. If the lock isn’t available, a thread gets blocked until the lock is released.
void lockInterruptibly() – This is similar to the lock(), but it allows the blocked thread to be interrupted and resume the execution through a thrown java.lang.InterruptedException.
boolean tryLock() – This is a nonblocking version of lock() method. It attempts to acquire the lock immediately, return true if locking succeeds.
boolean tryLock(long timeout, TimeUnit timeUnit) – This is similar to tryLock(), except it waits up the given timeout before giving up trying to acquire the Lock.
void unlock() unlocks the Lock instance.

A locked instance should always be unlocked to avoid deadlock condition.

In addition to the Lock interface, we have a ReadWriteLock interface that maintains a pair of locks, one for read-only operations and one for the write operation. The read lock may be simultaneously held by multiple threads as long as there is no write.

1. ReentrantLock
ReentrantLock - это наиболее часто используемый класс блокировок, который предоставляет те же возможности синхронизации, что и встроенные синхронизированные блоки и методы, но с дополнительными функциональными возможностями.
Особенности:
Reentrant: Повторно входной, что означает, что поток может захватить лок более одного раза.
Фейрнесс (справедливость): Может быть настроен для справедливого (fair) или несправедливого (unfair) распределения блокировок. В режиме справедливости потоки захватывают лок в порядке очереди.
Locking: Предоставляет методы lock(), lockInterruptibly(), tryLock() и unlock().
Condition Variables: Поддерживает создание условных переменных с помощью метода newCondition()
=============================================
ReentrantLock lock = new ReentrantLock();
lock.lock();
try {
    // критическая секция
} finally {
    lock.unlock();
}
=============================================
2. ReentrantReadWriteLock
ReentrantReadWriteLock предоставляет пару локов для управления доступом к ресурсу: один для чтения (read lock) и один для записи (write lock).

Особенности:

Разделение доступа: Позволяет множественным потокам читать ресурс одновременно, но только одному потоку записывать.
Reentrant: Как и ReentrantLock, поддерживает повторный вход.
Фейрнесс: Также может быть настроен для справедливого или несправедливого распределения блокировок.
Read Lock: Захватывается с помощью readLock().
Write Lock: Захватывается с помощью writeLock().
=============================================
ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();
ReentrantReadWriteLock.WriteLock writeLock = rwLock.writeLock();

readLock.lock();
try {
    // критическая секция для чтения
} finally {
    readLock.unlock();
}

writeLock.lock();
try {
    // критическая секция для записи
} finally {
    writeLock.unlock();
}
=============================================
3. StampedLock
StampedLock - это новый тип блокировки, представленный в Java 8, который предлагает механизмы для повышения производительности при работе с большими объемами данных, особенно в контексте чтения.

Особенности:

Три режима: Пессимистическая запись, пессимистическое чтение и оптимистическое чтение.
Stamped: Возвращает штампы (stamps) для каждой операции захвата лока.
Optimistic Read: Позволяет читать данные без полного захвата лока, но с последующей проверкой валидности (проверка штампа).
StampedLock lock = new StampedLock();
long stamp = lock.readLock();
try {
    // критическая секция для чтения
} finally {
    lock.unlockRead(stamp);
}

// Оптимистическое чтение
long stamp = lock.tryOptimisticRead();
try {
    // читайте данные
    if (!lock.validate(stamp)) {
        // если проверка не прошла, повторно захватите лок для чтения
        stamp = lock.readLock();
        try {
            // критическая секция для чтения
        } finally {
            lock.unlockRead(stamp);
        }
    }
} finally {
    // нет необходимости в явной разблокировке для оптимистического чтения
}
=============================================
4. Condition
Condition - это интерфейс, который позволяет потоку ожидать до тех пор, пока он не будет уведомлен о продолжении работы. Он используется совместно с классом Lock (например, ReentrantLock).

Особенности:

Condition Variables: Создание и управление условными переменными для сложной синхронизации.
Methods: Основные методы включают await(), signal(), и signalAll().
=============================================
ReentrantLock lock = new ReentrantLock();
Condition condition = lock.newCondition();

lock.lock();
try {
    while (!conditionMet) {
        condition.await(); // ожидание сигнала
    }
    // критическая секция
    condition.signalAll(); // сигнал всем ожидающим потокам
} finally {
    lock.unlock();
}
=============================================

=====(3)Классы-сихронизаторы из пакета java.util.concurrent.=====
https://habr.com/ru/articles/277669/ 
здесь более чем достаточно

=====(4)Модификатор volatile. Атомарные типы данных и операции.=====

В Java модификатор volatile, атомарные типы данных и операции предоставляют механизмы для безопасной работы с многопоточностью, обеспечивая видимость и атомарность операций. Разберём каждую из этих концепций.

Модификатор volatile
Модификатор volatile используется для указания JVM, что значение переменной может быть изменено разными потоками, и что оно должно быть прочитано и записано непосредственно из и в основную память, а не из кэша потока.

Особенности:

Видимость: Изменения переменной volatile, сделанные одним потоком, видны другим потокам немедленно.
Запрет на оптимизации: Компилятор и процессор не будут делать оптимизации, которые могли бы закэшировать значения переменной.
с
public class VolatileExample {
    private volatile boolean flag = false;

    public void setFlag() {
        flag = true;
    }

    public void checkFlag() {
        if (flag) {
            // Действия, выполняемые при flag == true
        }
    }
}
В этом примере, когда один поток изменяет значение flag, другие потоки немедленно увидят это изменение.
=============================================
Атомарные типы данных
Пакет java.util.concurrent.atomic предоставляет атомарные типы данных, которые поддерживают атомарные операции над целыми числами, булевыми значениями, массивами и объектными ссылками.

Основные атомарные классы:

AtomicInteger
AtomicLong
AtomicBoolean
AtomicReference
AtomicIntegerArray, AtomicLongArray, и другие
Эти классы обеспечивают атомарные операции, такие как сравнение и установка (compare-and-swap, CAS), которые могут быть использованы для реализации неблокирующих алгоритмов.

An int value that may be updated atomically. See the VarHandle specification for descriptions of the properties of atomic accesses. An AtomicInteger is used in applications such as atomically incremented counters, and cannot be used as a replacement for an Integer. However, this class does extend Number to allow uniform access by tools and utilities that deal with numerically-based classes.

import java.util.concurrent.atomic.AtomicInteger;

public class AtomicExample {
    private AtomicInteger counter = new AtomicInteger(0);

    public void increment() {
        counter.incrementAndGet(); // атомарное увеличение значения
    }

    public int getCounter() {
        return counter.get(); // атомарное получение значения
    }
}
Атомарные операции
Атомарные операции — это операции, которые выполняются как единое целое, неделимо. В многопоточном окружении это означает, что другие потоки не могут видеть промежуточные состояния таких операций.

Основные атомарные операции, поддерживаемые атомарными классами:
get(): Возвращает текущее значение.
set(): Устанавливает значение.
compareAndSet(expectedValue, newValue): Если текущее значение равно ожидаемому значению, устанавливает новое значение. Возвращает true, если установка прошла успешно.
getAndIncrement(), incrementAndGet(): Атомарное увеличение значения на единицу.
getAndDecrement(), decrementAndGet(): Атомарное уменьшение значения на единицу.
getAndAdd(delta), addAndGet(delta): Атомарное добавление заданного значения.
lazySet(): Устанавливает значение, не требуя немедленной видимости для других потоков.
1. Производительность
Оверхед атомарных операций: Атомарные операции (например, CAS — Compare-And-Swap) часто требуют аппаратной поддержки и могут быть дороже с точки зрения производительности по сравнению с простыми операциями над примитивами.
Кэширование и оптимизация: Примитивы и классы-оболочки могут использоваться с локальными переменными, которые могут быть закэшированы и оптимизированы компилятором, что невозможно с атомарными переменными из-за требований к видимости изменений между потоками.
2. Семантика использования
Семантика примитивов: Примитивы являются базовыми типами данных в Java и предоставляют простую, быструю и удобную работу для большинства однопоточных операций. Они не имеют дополнительных требований по синхронизации и управлению состоянием.
Семантика классов-оболочек: Классы-оболочки (например, Integer, Double) предоставляют дополнительные возможности и методы, такие как преобразования между типами, сравнение и т.д., которые не предоставляются атомарными классами.
Коллекции и другие структуры данных: Стандартные библиотеки Java и коллекции (List, Set, Map) работают с примитивами и их оболочками. Атомарные классы не могут быть напрямую использованы в таких коллекциях без дополнительной обёртки, что может усложнять код.

=====(5)Коллекции из пакета java.util.concurrent.=====
### Типы concurrent-коллекций:
1. ConcurrentHashMap:
- Хэш-таблица, позволяющая одновременное чтение и запись из нескольких потоков.
- Не блокирует всю таблицу при записи, а только отдельные сегменты.
- Более эффективна, чем `Hashtable` в многопоточных приложениях.
1. ConcurrentLinkedQueue:
- Очередь, основанная на связанном списке, позволяющая одновременное добавление и извлечение элементов из нескольких потоков.
- Не блокирует всю очередь при операциях, а только задействованные узлы.
- Эффективна для сценариев производитель-потребитель.
1. CopyOnWriteArrayList:
- Список, создающий копию массива при каждой операции модификации.
- Чтение происходит из оригинального массива, а запись - в копию.
- Подходит для сценариев с большим количеством чтений и небольшим количеством записей.
1. CopyOnWriteArraySet:
- Множество, основанное на `CopyOnWriteArrayList`.
- Обеспечивает те же характеристики, что и `CopyOnWriteArrayList`, но для множеств.
1. ConcurrentSkipListMap и ConcurrentSkipListSet:
- Отсортированные карта и множество, основанные на пропускающем списке.
- Поддерживают эффективные операции поиска, вставки и удаления.
- Подходят для сценариев, где важен порядок элементов.
1. Блокирующие очереди (BlockingQueue):
- Очереди, поддерживающие операции блокировки при добавлении и извлечении элементов.
- Обеспечивают безопасную передачу данных между потоками.
- Примеры: `LinkedBlockingQueue`, `ArrayBlockingQueue`, `PriorityBlockingQueue`.

### Преимущества concurrent-коллекций:

- Безопасность потоков: предотвращают состояния гонки и несогласованность данных.
- Производительность: оптимизированы для работы в многопоточной среде.
- Удобство использования: предоставляют знакомый интерфейс, похожий на обычные коллекции.

### Выбор concurrent-коллекции:

Выбор зависит от конкретной задачи и требований приложения:

- ConcurrentHashMap: для частого чтения и записи с использованием ключей.
- ConcurrentLinkedQueue: для эффективной обработки очередей в сценариях производитель-потребитель.
- CopyOnWriteArrayList: для сценариев с большим количеством чтений и небольшим количеством записей.
- ConcurrentSkipListMap и ConcurrentSkipListSet: для отсортированных коллекций.
- BlockingQueue: для безопасной передачи данных между потоками.


Правила happens-before в Java Memory Model (JMM) определяют порядок видимости операций в многопоточном окружении. Эти правила гарантируют, что изменения, сделанные одним потоком, будут видны другим потокам в определённых обстоятельствах, помогая избежать проблем с памятью и синхронизацией.
(1)Правило программы (Program Order Rule)
В пределах одного потока операции происходят в порядке, в котором они указаны в программе.
(2)Правило монитора (Monitor Lock Rule)
Операции, выполняемые до выхода из блока синхронизации (synchronized), happens-before операций, выполняемых после входа в блок синхронизации на том же мониторе в другом потоке.
synchronized (lock) {
    sharedVariable = 1; // happens-before
}
synchronized (lock) {
    int value = sharedVariable; // чтение происходит после записи
}
(3)Правило volatile (Volatile Variable Rule)
Запись в volatile переменную happens-before чтения этой переменной. 
(4)Правило потока (Thread Start Rule)
start() раньше run();
(5)Правило завершения потока (Thread Termination Rule)
Завершение потока happens-before любому действию, которое обнаруживает завершение этого потока, например, вызову метода Thread.join().

=====(6)Интерфейсы Executor, ExecutorService, Callable, Future.=====
## Интерфейсы Executor, ExecutorService, Callable, Future:

Эти интерфейсы играют ключевую роль в выполнении задач в отдельных потоках, управлении ими и получении результатов.

### Executor:

- Базовый интерфейс для запуска новых задач.
- Определяет единственный метод `execute(Runnable command)`, который принимает объект `Runnable` и запускает его в новом потоке или использует существующий поток из пула.

### ExecutorService:

- Расширяет интерфейс `Executor` и предоставляет дополнительные методы для управления жизненным циклом задач и пула потоков.
- Основные методы:
    - `submit(Callable<T> task)`: запускает задачу, которая может вернуть результат (тип T), и возвращает объект `Future<T>` для получения результата.
    - `submit(Runnable task)`: запускает задачу, которая не возвращает результат, и возвращает объект `Future<?>`.
    - `shutdown()`: плавно завершает работу сервиса, дожидаясь завершения всех запущенных задач.
    - `shutdownNow()`: пытается немедленно остановить все запущенные задачи и возвращает список задач, которые не были запущены.
    - `awaitTermination(long timeout, TimeUnit unit)`: ожидает завершения работы сервиса в течение заданного времени.
    - `invokeAll(Collection<? extends Callable<T>> tasks)`: запускает набор задач и ожидает завершения всех задач.
    - `invokeAny(Collection<? extends Callable<T>> tasks)`: запускает набор задач и возвращает результат первой успешно выполненной задачи.

### Callable:

- Интерфейс, похожий на `Runnable`, но с возможностью возвращать результат.
- Определяет метод `call()`, который выполняет задачу и возвращает результат (тип T).

### Future:

- Интерфейс, представляющий результат асинхронного выполнения задачи.
- Основные методы:
    - `get()`: блокирует текущий поток до тех пор, пока результат задачи не будет доступен, и возвращает результат.
    - `get(long timeout, TimeUnit unit)`: блокирует текущий поток на заданное время и возвращает результат, если он доступен.
    - `isDone()`: проверяет, завершилась ли задача.
    - `isCancelled()`: проверяет, была ли задача отменена.
    - `cancel(boolean mayInterruptIfRunning)`: пытается отменить задачу.

### Преимущества использования Executor, ExecutorService, Callable, Future:

- Упрощение разработки многопоточных приложений: предоставляют удобные механизмы для запуска, управления и получения результатов задач в отдельных потоках.
- Улучшение производительности: позволяют эффективно использовать ресурсы процессора и памяти.
- Гибкость: предоставляют различные варианты управления пулом потоков и жизненным циклом задач.

=====(6)Пулы потоков=====
Пулы потоков - это механизм управления группой рабочих потоков, которые используются для выполнения задач.  Вместо создания нового потока для каждой задачи, пул позволяет повторно использовать существующие потоки, что повышает эффективность и производительность приложения.

### Преимущества пулов потоков:

- Уменьшение накладных расходов на создание и уничтожение потоков: создание и уничтожение потоков - ресурсоемкие операции. Пул позволяет избежать этих затрат, повторно используя существующие потоки.
- Управление количеством потоков: пул позволяет ограничить количество одновременно выполняемых потоков, что предотвращает перегрузку системы.
- Упрощение управления задачами: пул предоставляет удобные методы для отправки задач на выполнение и получения результатов.

### Типы пулов потоков:
- FixedThreadPool: пул с фиксированным количеством потоков. Подходит для задач с известным количеством параллельных операций.
- CachedThreadPool: пул, создающий новые потоки по мере необходимости и повторно использующий существующие потоки, если они доступны. Подходит для задач с переменной нагрузкой.
- SingleThreadExecutor: пул с одним потоком. Подходит для задач, которые необходимо выполнять последовательно.
- ScheduledThreadPool: пул, позволяющий планировать выполнение задач в определенное время или с заданной периодичностью.

## JDBC: Взаимодействие с базой данных

JDBC (Java Database Connectivity) - это API, предоставляющее унифицированный способ взаимодействия Java-приложений с различными реляционными базами данных.

### Порядок взаимодействия с базой данных:

1. Загрузка драйвера JDBC:
    - Загрузить класс драйвера с помощью `Class.forName(driverClassName)`.
    - Драйвер регистрируется в `DriverManager` и становится доступным для создания подключений.
2. Получение подключения:
    - Вызвать метод `DriverManager.getConnection(url, username, password)`.
    - `url`: строка подключения, содержащая информацию о базе данных, сервере и других параметрах.
    - `username` и `password`: учетные данные для доступа к базе данных.
    - Метод возвращает объект `Connection`, представляющий подключение к базе данных.
3. Создание объекта Statement:
    - Вызвать метод `Connection.createStatement()`.
    - `Statement` используется для выполнения SQL-запросов.
4. Выполнение SQL-запроса:
    - Вызвать метод `Statement.executeQuery(sql)` для выполнения запроса, возвращающего набор данных (SELECT).
    - Вызвать метод `Statement.executeUpdate(sql)` для выполнения запроса, изменяющего данные (INSERT, UPDATE, DELETE).
5. Обработка результатов:
    - Для запросов `SELECT` использовать объект `ResultSet` для получения данных из результирующего набора.
    - Для запросов `UPDATE`, `INSERT`, `DELETE` получить количество измененных строк.
6. Закрытие ресурсов:
    - Закрыть `ResultSet`, `Statement` и `Connection` в обратном порядке, чтобы освободить ресурсы.

### Класс DriverManager:

- Регистрирует драйверы JDBC и управляет ими.
- Предоставляет статический метод `getConnection()` для получения подключений к базе данных.

### Интерфейс Connection:

- Представляет подключение к базе данных.
- Основные методы:
    - `createStatement()`: создает объект `Statement` для выполнения SQL-запросов.
    - `prepareStatement(sql)`: создает объект `PreparedStatement` для выполнения параметризованных SQL-запросов.
    - `close()`: закрывает подключение к базе данных.
    - `setAutoCommit(boolean)`: устанавливает режим автоматической фиксации транзакций.
- Интерфейсы `Statement`, `PreparedStatement`, `ResultSet`, `RowSet`
    
    ## Интерфейсы Statement, PreparedStatement, ResultSet, RowSet в JDBC
    
    Эти интерфейсы играют ключевую роль в выполнении SQL-запросов и обработке результатов в JDBC.
    
    ### Statement:
    
    - Используется для выполнения статических SQL-запросов.
    - Основные методы:
        - `executeQuery(String sql)`: выполняет запрос SELECT и возвращает объект `ResultSet` с результатами.
        - `executeUpdate(String sql)`: выполняет запрос INSERT, UPDATE или DELETE и возвращает количество измененных строк.
    
    ### PreparedStatement:
    
    - Расширяет интерфейс `Statement` и позволяет использовать параметризованные SQL-запросы.
    - Преимущества:
        - Безопасность: предотвращает SQL-инъекции, так как параметры обрабатываются отдельно от SQL-кода.
        - Производительность: запрос компилируется один раз, а затем может выполняться несколько раз с разными параметрами.
    - Основные методы:
        - `setXXX(int parameterIndex, XXX value)`: устанавливает значение параметра с заданным индексом (XXX - тип данных, например, setString, setInt).
        - `executeQuery()`: выполняет параметризованный запрос SELECT и возвращает `ResultSet`.
        - `executeUpdate()`: выполняет параметризованный запрос INSERT, UPDATE или DELETE и возвращает количество измененных строк.
    
    ### ResultSet:
    
    - Представляет набор данных, полученный в результате выполнения запроса SELECT.
    - Основные методы:
        - `next()`: перемещает курсор на следующую строку результата.
        - `getXXX(int columnIndex)` или `getXXX(String columnLabel)`: получает значение указанного столбца в текущей строке (XXX - тип данных, например, getString, getInt).
        - `close()`: закрывает `ResultSet`.
    
    ### RowSet:
    
    - Расширяет интерфейс `ResultSet` и предоставляет дополнительные возможности для работы с результатами запроса.
    - Основные типы RowSet:
        - JdbcRowSet: подключенный `RowSet`, который поддерживает прямое подключение к базе данных.
        - CachedRowSet: отключенный `RowSet`, который кэширует результаты запроса в памяти.
        - WebRowSet: отключенный `RowSet`, который может быть сериализован и передан по сети.
    - Преимущества:
        - Отключение от базы данных: `CachedRowSet` и `WebRowSet` позволяют работать с результатами запроса без постоянного подключения к базе данных.
        - События: `RowSet` может генерировать события при изменении данных.
    
    ### Пример использования PreparedStatement и ResultSet:
    
    String sql = "SELECT * FROM users WHERE username = ?";
    PreparedStatement statement = connection.prepareStatement(sql);
    statement.setString(1, "john.doe");
    ResultSet resultSet = statement.executeQuery();
    
    while (resultSet.next()) {
    String username = resultSet.getString("username");
    // ...
    }
    
    resultSet.close();
    statement.close();
    
    ### Выбор между Statement и PreparedStatement:
    
    - Statement: используйте для простых, статических SQL-запросов, которые выполняются один раз.
    - PreparedStatement: используйте для параметризованных запросов, которые выполняются несколько раз с разными параметрами, а также для предотвращения SQL-инъекций.
    
    ### Выбор между ResultSet и RowSet:
    
    - ResultSet: используйте для базовой обработки результатов запроса.
    - RowSet: используйте, когда требуется отключение от базы данных, кэширование результатов или поддержка событий.
    
    Важно помнить, что правильное использование этих интерфейсов повышает безопасность, производительность и гибкость работы с базами данных в Java-приложениях.
