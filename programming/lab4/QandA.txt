=====ВСЁ ПРО КЛАССЫ=====
всего 4 разных вида внутренних классов, делятся они на 2 основные группы: 
1)nested(вложенные классы, статические внутренние классы)
2)inner(внутренние классы, сюда входят: локальные, анонимные и просто внутренние)

1)NESTED(STATIC INNER CLASS\NESTED CLASS)
Статический вложенный класс – это класс (или !!!ИНТЕРФЕЙС!!!), определенный как static внутри другого класса(имеет доступ только к static полям и методам внешнего класса, вызов во внешнем классе осуществляется через NestedClass.someMethod(), то есть через название класса и метода). Любой класс, помещенный в интерфейс, автоматически объявляется как открытый (public) и статический (static).

Компилятор все равно создаст этот класс как класс, только через упоминание внешнего класса: Outer$Nested.class

====пример использования=====
class OuterClass { 	
	static class NestedClass{}
	static interface StaticNestedInterface{}
}

статический вложенный класс не связан ни с одним экземпляром внешнего класса, то есть может использоваться без создания экземпляра внешнего класса. Тем не менее статический вложенный класс имеет доступ ко всем static членам окружающего класса, включая любые другие статические вложенные классы и интерфейсы. Статический вложенный класс class Bell{}
        }может использовать любой статический член окружающего класса без указания имени этого окружающего класса.
Статический вложенный класс имеет доступ ко всем статическим членам окружающего класса, включая private члены. Обратное тоже верно: методы окружающего класса имеют доступ ко всем static членам статического вложенного класса, включая его private static члены, однако при обращении к ним необходимо указывать имя статического вложенного класса, которому они принадлежат.

Создание объекта вложенного класса(создается через Внеш.Влож = new Внеш.Влож()): 
OuterClass.NestedClass name = new OuterClass.NestedClass();
аналогично можно использовать поля и методы вложенного класса, то есть через обращение по классам(если поля или методы static)

==================================
	
2)INNER(ВНУТРЕННИЕ КЛАССЫ)
Внутренний класс определяется внутри окружающего класса, но он объявляется без модификатора static. 
Этот тип внутренних классов является аналогом методов и полей экземпляра. 
Экземпляр внутреннего класса всегда связан с экземпляром окружающего класса, а код внутреннего класса имеет доступ ко всем полям и методам (как статическим, так и нестатическим) окружающего класса. 
Подобно полям и методам экземпляра, каждый экземпляр внутреннего класса связан с экземпляром класса, внутри которого он определен (то есть каждый экземпляр внутреннего класса связан с экземпляром его окружающего класса). Вы не можете создать экземпляр внутреннего класса без привязки к экземпляру внешнего класса. То есть сперва должен быть создан экземпляр внешнего класса, а только затем уже вы можете создать экземпляр внутреннего класса.
=====пример использования=====
class Outer {
	class Inner{}
}

Экземпляр внешнего класса не имеет доступа ни к каким членам экземпляра внутреннего класса на прямую, то есть без создания экземпляра внутреннего класса внутри своих методов.
Внутренний класс не может иметь полей, методов или классов, объявленных как static (за исключением полей констант, объявленных как static и final). Статические поля, методы и классы являются конструкциями верхнего уровня, которые не связаны с конкретными объектами, в то время как каждый внутренний класс связан с экземпляром окружающего класса.


3)LOCAL CLASSES(ЛОКАЛЬНЫЕ КЛАССЫ)
Локальный класс – это класс, определенный в блоке Java-кода. Как и локальная переменная, локальный класс виден только внутри блока. 
Локальным классам присущи многие особенности внутренних классов. Кроме того, локальные классы могут работать с любыми final переменными или параметрами, которые доступны в блоке, где класс был определен. Интерфейсы нельзя определить локально.


4)ANONYMOUS CLASSES(АНОНИМНЫЕ КЛАССЫ)
Анонимный класс – это вид локального класса без имени; он комбинирует синтаксис для объявления класса с синтаксисом для присвоения значения объекту. 
Объявление локального класса – это оператор Java, а определение анонимного класса (и присвоение значения) – это выражение Java, поэтому такое определение может появляться только как часть еще большего выражения, например вызова метода. Интерфейсы нельзя определить анонимно.


Конструкторы в анонимных классах ни определять, ни переопределять нельзя. Анонимный класс не может иметь конструкторов, поскольку имя конструктора должно совпадать с именем класса, а в данном случае класс не имеет имени.

Любые аргументы, которые вы укажете в круглых скобках, стоящих за именем родительского класса в определении анонимного класса, неявно передаются конструктору родительского класса.
Анонимные классы допускают вложенность друг в друга
объявление анонимного класса представляет собой выражение. Это означает, что его можно записать как часть большего выражения, например вызова метода

Если имя, следующее за ключевым словом new, это имя класса, то анонимный класс является подклассом этого класса. Если имя, следующее за ключевым словом new, представляет собой интерфейс, то анонимный класс реализует этот интерфейс и расширяет класс Object. Данный синтаксис не позволяет указать секции extends, implements или имя класса. В следствии этого анонимный класс может реализовать только один интерфейс.

компилятор использует номера в качестве идентификаторов для таких классов. В откомплиривонном виде класс будет выглядить примерно так: Outer$1.class

обращаться к объекту анонимного класса можно также, как и к локальному: anonymousClassName.this

Имеют такой же доступ, как и локальные, то есть: имеют доступ к локальным переменным своего блока кода, которые объявлены как final или effectivly final(то есть не изменяются в течение цикла)

Имеют доступ ко всем членам внешнего класса

Анонимный класс не может определять статические поля, методы или классы, кроме констант static final. Интерфейс не может быть объявлен анонимно, потому что нет способа реализовать интерфейс без имени. Так же как и локальные классы, анонимные классы не могут быть public, private, protected или static.

В анонимном классе вы не можете объявить статические инициализационные блоки.

В анонимном классе вы не можете объявить интерфейс.

Поскольку у анонимного класса нет имени, то невозможно определить конструктор анонимного класса. Если вашему классу нужен конструктор, вы должны задействовать локальный класс. Впрочем, зачастую в качестве замены конструктора можно применять инициализатор экземпляра.

В анонимном классе вы можете объявить:(Поля, Дополнительные методы, (даже если этих методов нет в классе родителе), Инициализационные блоки экземпляра, Локальные классы)

Примеры инициализации анонимного класса:
====================================
interface Iout{void justPrint();}
class External {
	some poles and methods
}
class Outer {
	void outPrint() {
		Iout iout = new Iout(){//some methods here//}; //через интерфейс (создается анонимный класс, реализующий интерфейс)
	}
	void extPrint() {
		External ext = new External(){//some methods here//}; //через внешний класс (создается класс, наследуемый от другого)
	}
}	


=====ERRORS AND EXCEPTIONS=====
ИЕРАРХИЯ ИСКЛЮЧЕНИЙ
Error - ошибка при работе JVM. Это ошибка связанна с говно-кодом. 
К примеру, когда метод сам себя вызывает (StackOverFlowError)
Памяти нет чтобы создать ещё объкты (MemoryError)

Checked - проверяемые исключения. В отличие от unchecked мы обязаны указать, что их выкидываем.

Unchecked - можно отловить, а можно и не отлавливать
Таким образом, три типа исключений - это Errors, RuntimeException и Exception, из которых Exception - checked исключения, а все остальные - Unchecked. 

Существует небольшая иерархия - Errors исключения - вовсе не желательны к обработке, Runtime - возможны по нашему усмотрению, IOstream - обязательны к обработке.

Исключения типа Runtime в большинстве своем можно обрабатывать через if-else, а не через try-catch, так как обработка через try-catch более медленная. ~примерная разница в обработке простой ситуации через if-else и try-catch - десять миллисекунд.	

Операторы программы, которые вы хотите отслеживать, помещаются в блок try. Если исключение произошло, то оно создаётся и передаётся дальше. Ваш код может перехватить исключение при помощи блока catch и обработать его. Системные исключения автоматически передаются самой системой. Чтобы передать исключение вручную, используется throw. Любое исключение, созданное и передаваемое внутри метода, должно быть указано в его интерфейсе ключевым словом throws. Любой код, который следует выполнить обязательно после завершения блока try, помещается в блок finally.
try {
    // блок кода, где отслеживаются ошибки
}
catch (тип_исключения_1 exceptionObject) {
    // обрабатываем ошибку
}
catch (тип_исключения_2 exceptionObject) {
    // обрабатываем ошибку
}
finally {
    // код, который нужно выполнить после завершения блока try
}

Существует специальный класс для исключений Trowable. В него входят два класса Exception и Error.

===============================================================
ТУТ ДАЛЬШЕ МОЖЕШЬ НЕ ЧИТАТЬ ТУТ УЖЕ ПРИКОЛЫ ВСЯКИЕ НАПИСАНЫ ТЕБЯ ОБ ЭТОМ НЕ СПРОСЯТ
Рефлексия (от позднелат. reflexio — обращение назад) — это механизм исследования данных о программе во время её выполнения. Рефлексия позволяет исследовать информацию о полях, методах и конструкторах классов.

Сам же механизм рефлексии позволяет обрабатывать типы, отсутствующие при компиляции, но появившиеся во время выполнения программы. Рефлексия и наличие логически целостной модели выдачи информации об ошибках дает возможность создавать корректный динамический код.
        
Иначе говоря, понимание принципов работы рефлексии в java открывает перед вами ряд удивительных возможностей. Вы буквально можете жонглировать классами и их составляющими.

Вот основной список того, что позволяет рефлексия: 
Узнать/определить класс объекта;
Получить информацию о модификаторах класса, полях, методах, константах, конструкторах и суперклассах;
Выяснить, какие методы принадлежат реализуемому интерфейсу/интерфейсам;
Создать экземпляр класса, причем имя класса неизвестно до момента выполнения программы;
Получить и установить значение поля объекта по имени;
Вызвать метод объекта по имени.

Аннотации в Java являются своего рода метками в коде, описывающими метаданные для функции/класса/пакета
Аннотации - это форма метаданных. Они предоставляют информацию о программе, при том сами частью программы не являются.
применяются для комплятора(обнаружение ошибок и подавление предупреждений), обработка во время компиляции(программа может создавать код), обработка во время выполнения.

Аннотация — это специальная конструкция языка, связанная с классом, методом или переменной, предоставляющая программе дополнительную информацию,
 на основе которой программа может предпринять дальнейшие действия или реализовать дополнительную функциональность, такую как генерация кода, проверка ошибок и т. д.

