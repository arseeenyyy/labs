ORG 0x0 
V0:	WORD $default, 0x180 	 
V1: WORD $int1, 0x180  	
V2: WORD $default, 0x180 
V3: WORD $int3, 0x180  
V4: WORD $default, 0x180
V5: WORD $default, 0x180
V6: WORD $default, 0x180
V7: WORD $default, 0x180

default: IRET 

ORG 0x46 
X:	WORD ?
MIN: WORD 0xFFD2 ; минимальное значение X
MAX: WORD 0x0041 ; максимальное значение X

START:	DI ; запрет прерываний
		CLA ; очистка аккумулятора
		OUT 0x1 
		OUT 0x5 
		OUT 0xB
		OUT 0xE 
		OUT 0x12 ; запрет прерываний для неиспользуемых ВУ
		OUT 0x16 
		OUT 0x1A
		OUT 0x1E 
		LD #0x9 ; загрузить в аккумулятор MR(1000|0001=1001)
		OUT 0x3 ; разрешение прерывания на ВУ-1
		LD #0xB ; загрузить в аккумулятор MR(1000|0011=1011)
		OUT 0x7 ; разрешение прерываний на ВУ-3
 		EI  
main:	DI ; запрет прерываний для обеспечения атомарности операции
		LD $X ; прямая абсолютная загрузка операнда X
		SUB #0x3 ; AC(X) - 0x3 
		CALL CHECK ; вызов подпрограммы (проверка на одз)
		ST $X ; сохранение X
		EI ; разрешение прерываний
		JUMP main ; безусловный переход на основную программу
;обработка прерывания на ву - 1
int1:	DI ; запрет прерывания
		PUSH ; помещаем AC в стек
		LD X ;загрузка операнда X
		NOP ;отладочная точка ОСТАНОВ
		ASL ; умножение на 2
		SUB #0x3 ; вычитание 0x3
		NOP ; отладочная точка ОСТАНОВ
		CALL CHECK ; вызов подпрограммы (проверка на одз)
		OUT 0x2 ; вывод результата на текущее ВУ (ВУ-1)
		POP ; достаем AC из стека
		EI ; разрешаем прерывания
		IRET ; возврат из прерывания
;обработка прерывания на ву - 3		
int3:	DI ; запрет прерывания 
		PUSH ; поместили AC в стек 
		IN 6 ; записываем содержимое РДВУ текущего ВУ
		AND #0x1F ; оставляем 5 младших разрядов(остальные - 0)
		AND $X ; побитовое маскирования РДВУ и X
		NOP ; отладочная точка ОСТАНОВ
		CALL CHECK ; вызов подпрограммы (проверка на одз)
		ST $X ; сохранение результата
		NOP ; отладочная точка ОСТАНОВ
		POP ; достаем AC из стека
		EI ; разрешаем прерывания 
		IRET ; возврат из прерывания
;подпрограмма для проверки ОДЗ
CHECK:	
check_max:	CMP $MAX ; сравниваем с максимальным
			BGE load_max ; IF (X) > $MAX -> X = LD $MAX
			JUMP check_min ; IF (X) < MAX -> сравниваем с минимальным
check_min:	CMP $MIN ; сравниваем с минимальным
			BLT load_max ; IF (X) < $MIN -> X = LD $MIN
			JUMP return ; безусловный переход на возврат, если X в пределах ОДЗ
load_max:	LD $MAX ; загрузка максимального значения
return:		RET	; возврат из подпрограммы проверки ОДЗ
