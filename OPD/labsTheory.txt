=====РЕГИСТРЫ, ФЛАГИ и ТРИГГЕРЫ=====
Триггер - 1 битовая ячейка, которая хранит состояние. Регистр - это совокупность единичных триггеров, у которых объединены управляющие входы в 1 управляющий вход.
1)Ip (Instruction Pointer) - 11 разрядов, указывает на номер ячейки, в которой содержится следующая исполняемая команда. 
увеличивается на 1 при каждой новой команде(IP -> BR, AR); BR + 1 -> IP
2)AR (Adress Register) - 11 разрядов, служит для организации обращения к ячейкам памяти и содержит адресс ячейки, к которой обращается процессор
3)DR (Data Register) - 16 разрядов, единственный регистр, который напрямую взаимодействует с ячейками памяти, нужен он для временного хранения значения ячейки памяти при обмене информацией между памятью и процессором
MEM(AR) -> DR
4)CR (Command Register) - 16 разрядов, хранит код исполняемой в данный момент команды с целью ее поэтапного декодирования и выполнения требуемых операций
5)BF (Buffer Register) - 16 разрядов, служит для хранения данных во время работы
6)SP (Stack Pointer) - 11 разрядов, указывает на вершину стека, предназначен для хранения адресов возврата и параметров подпрограммы и прерываний 
7)IR (Input Register) - 16 разрядов, находится в составе пульта эвм, предназначен для ввода адреса, комманд и данных. 
8)PS (Programm State) - 16 разрядов, хранит биты управляющие работой бэвм(работа, прерывание) и признаки результата(используются только 9 младших разряда)

=====Система команд=====	
4 группы команд: 
1)безадресные 
2)команды ввода - вывода 
3)адресные команды
4)команды ветвления
выбор команды осуществляется МПУ при помощи анализа старших четрых бит кода команды (с 15 по 12 бит), называются КОП(Код операции, Code operation)

всего 6 форматов 16-битовых команд с 4-битовым кодом операции: 

1)Безадресные команды КОП=0000 ([15][14][13][12][11][10][9][8][7][6][5][4][3][2][1][0]) [15-12] - КОП(уставлены 0), [11-0]- расширение КОП
выполняют различные действия без ссылок на ячейку памяти. Например CLA

2)Команды ввода-выводы КОП=0001 ([15][14][13][12][11][10][9][8][7][6][5][4][3][2][1][0]) [15-12] - КОП(уставлены 0001), [11-8] - приказ, [7-0] устройство
управляют обменом данными между процессором и внешним устройством ЭВМ

Адресные команды предписывают машине производить действия с ячейкой памяти, адрес которой определяется исходя из адресной части команды
3)Адресная команда с абсолютной адресацией [11]=0 ([15][14][13][12][11][10][9][8][7][6][5][4][3][2][1][0]), [15-12]-КОП, [11]=0, [10-0]-адрес
При выполнении операции команда непосредственно обращается по заданному адресу выбирая или записывая операнд

4)Адресная команда с относительной адресацией [11]=1 ([15][14][13][12][11][10][9][8][7][6][5][4][3][2][1][0]), [15-12]-КОП, [11]=1, [10-8]-режим, [7-0]-смещение
смещение используется для вычисления адреса операнда в памяти с помощью прибавления смещения к значению IP

5)Команда с прямой(непосредственной) загрузкой операнда ([15][14][13][12][11][10][9][8][7][6][5][4][3][2][1][0]), [15-12]-КОП, [11]=1, [10-8]=111, [7-0]-число

6)Команда ветвления КОП=1111 ([15][14][13][12][11][10][9][8][7][6][5][4][3][2][1][0]), [15-12]=1111, [11-8]-Расширение КОП, [7-0]-Смещение
Позволяют продолжить вычислительный процесс с другого адреса программы в зависимости от состояния NZVC

=====Устройство управления=====
=====Instruction fetch=====
Выполняет машинные команды.
Цикл команд: 
1)цикл выборки команды(instruction fetch IF) - нужен для того, чтобы извлечь команду, которую будем выполнять, код команды извлекается и помещается в CR
2)цикл выборки адреса(Adress fetch AF) - используется только в случае адресных команд, заканчивается выборокой операнда, который находится в памяти
3)цикл выборки операнда(operand fetch OF) - берет операнд и размещает его в DR 
4)цикл исполнения(Execution EX) - есть у каждой команды, но для каждой команды он разный
5)Цикл прерывания(interruption INT) 

=====ЦИКЛЫ ПУЛЬТОВЫХ ОПЕРАЦИЙ=====
1)ввод адреса
2)чтение 
3)запись
4)пуск

=====ADD/ADC=====
ADC - сложение с учетом значения C флага 
ADD - сложение
=====SUB/CMP=====
CMP - сравнение, реализуется через разность операндов, но результат не записывается в аккумулятор, а лишь устанавливаются признаки результата (Z=0 => операнды равны)
SUB - вычитание, реализуется через доп.код числа

=====Основные команды=====
0100 - HLT Останов
0200 - CLA 0 -> AC
0280 - NOT ^AC -> AC
0300 - CLC - 0 -> CLC
0400 - ROL - AC15 -> C, C -> AC0
0480 - ROR - AC0 -> C, C -> AC15 
0500 - ASL - AC15 -> 0 0 -> AC0
0580 - ASR - AC0 -> C AC15 -> AC14 
0700 - INC - AC + 1 -> AC
0780 - DEC - AC - 1 -> AC
0780 - NEG - ^AC + 1 -> AC

2XXX - AND M - M & AC -> AC
3XXX - OR M - ^(^AC & ^M) -> AC
4XXX - ADD M - AC + M -> AC
5XXX - ADC M - M + AC + C -> AC
6XXX - SUB M - AC - M -> AC
AXXX - LD M - M -> AC
EXXX - ST M - AC -> M

=====Потактовое исполнение команд=====
ADD21(на примере картинки из методы)
1)IP -> BR, AR (содержимое IP через АЛУ записывается в BR, а младшие 11 разрядов BR -> AR)
2)BR + 1 -> IP, MEM(AR)	-> DR (содержимое BR увеличивается на 1 и записывается в IP, одновременное содержимое ячейки по адресу AR читается в DR)
3)DR -> CR (содержимое DR через АЛУ записывается в CR)
4)DR -> AR (младшие 11 разрядов DR записываются в AR, адрес операнда из команды)
5)MEM(AR) -> DR(загрузка операнда из памяти в DR)
6)AC + DR -> AC; NZVC (содержимое DR на правом входе АЛУ складывается с содержимым AC на левом входе в АЛУ и записывается в AC, признаки результата записываются в младшие 4 бита PS, и обнуляются)

=====Архитектуры=====
1)Гарвардская 
Из чего состоит: I\O(input\output), ALU, data memory, instruction memory, control unit(микропроцессор)

ОСНОВНОЕ ОТЛИЧИЕ: ПАМЯТЬ ДЛЯ КОМАНД И ДЛЯ ДАННЫХ В ГАРВАРДСКОЙ ВЫНЕСЕНЫ ОТДЕЛЬНО(разная организация обращения к памяти)
2)Фон неймана
Из чего состоит: input device, output device, central processing unit{control unit, alu, memory unit}

=====ПАМЯТЬ=====
Память в бэвм - адресуемая, можно обращаться в любое место памяти(место четко обозначается адресом ячейки)
1)ДЕШИФРАТОР
есть n количество входов, значит 2^n количество выходов
подаем какой то адрес, он выдает нам на выходе установленную ту линию, которая закодирована в нашей команде(подали команду 011(3) -> линия с номером три будет установлена, подаем 7 -> задаем 7 линию, позволяет выбрать строку из памяти)

2)ПАМЯТЬ
на входе в память стоит дешифратор, подается адрес и выбирается одна из 2048 линий, на которой находится запоминающий элемент

=====Операции АЛУ=====
Арифметико-логическое устройство, выполняющее операции инвертирования, сложения, логического умножения, добавления единицы к результату и учавствующее в организации циклических сдвигов содержимого аккумулятора и регистра переноса. 	
Состоит из 2 входов(левый и правый), на входе каждая шина может проводить инверсию
есть вентиль на +1 

=====Коммутатор=====
это устройство, на которое поступает 18 разрядов результата операции из АЛУ(результат - 16 бит и биты необходимые для формирования признака переноса), а также предыдущее значение переноса из PS.
Коммутатор выполняет операции циклических и арифметических сдвигов, расширении знака младшего байта в старший. 
На вход подаются два байта операнда после алу, содержатся также признаки предыдущего результата. 

=====Блок проверки установки результата=====
стоит ниже коммутатора, задает nzvc

=====Carry и oVerflow=====
overflow - сумма по модулю 2 переноса из 14 в 15 и из 15 в 16(для знаковых чисел)
carry - перенос из 15 в 16(для беззнаковых)

=====Функциональные элементы ЭВМ=====
1)Элементы хранения(DRAM/SRAM)
dram - динамическая(используются конденсаторы и очень мало транзисторов, чаще используется как основная память компьютера), 
sram - статическая(используются транзисторы и защелки, хранит данные пока есть питание)

2)Провода, шины
шина - совокупность проводов, по которым передается информация одного назначения. 

3)Вентили - элемент, предназначенный для управления передачи информации(работает по принципу крана, открывая или закрывая путь сигналам).

4)Сумматор(входит в алу) - 3 входа, 2 выхода

5)Тактовые генераторы - генерирует импульсы с заданной частатой(частота - величина постоянная, каждая операция выполняется за определенное количество тактов, чем выше тактовая частота - тем быстрее цп выполняет операции)

=====Представление логических операндов=====
представлять логические операнды как числовые значения и писать такое же одз - НЕЛЬЗЯ
для них одз: X_{i} принадлежит {0,1}, где 0<=i<=15

=====Представление символьной и текстовой информации=====
Символы хранятся в шрифтах. В ОС есть папка font, коду буквы соответствует начертание буквы. В БЭВМ шрифты двух видов: растровое и векторное
Растровое - состоят из пикселей
Векторные - из линий/цветов/фигур описанных формулами.
Одной из первых основных кодовых таблиц стала ASCII(AmericanStandartCodeInformationInterchange)
Предусмотрено 128 символом, является семибитной. 
В коде старший символ отсутсвует, старший бит позволяет контролировать четность битов. 
Кодировки КОИ(КодОбменаИнформации) - аналог ascii с русскими символами
Кодировка ISO8859-5(гост-кодировка)
Unicode - это глобальный стандарт кодирования символов, который предоставляет уникальное число для обозначения каждого символа, используемого в современных вычислениях, включая технические символы и специальные символы, используемые при публикации.
utf-8 
little endian: 
big endian: 
Представление строк в бэвм:
1)NUL terminated string: когда заканчивается последовательность символов в памяти, после нее должен стоять символ nul с кодом 0
2)Упаковка с длиной(как в паскале): первый символ строки - длина строки(строка должна быть обязательно той длины, которая указана, если нет, то слово обрежет)

=====ПИРАМИДА ПАМЯТИ=====
тип памяти:		Объем:		Тип 		управление 
СPU 			100-1000 б		регистр	компилятор
L1 cache		32-128 кб		Ассоц.	аппаратура
L2-L3 cache 	0.5-32 мб		Ассоц.	аппаратура
основная память	0.5 гб-4 тб		адресная	программно
SSD 			128 гб-1 тб		блоч.		программно
жесткие диски 	0.5 тб-4 тб		блоч.		программно
магнитные ленты	1- 6тб		последов.	программно



|===================================================================|
|					ЛАБА №3					  						|
|===================================================================|

=====32-х Разрядные числа=====
1)СУММИРОВАНИЕ:
складываем младшие слова(первые 16 бит) первого и второго числа, сохраняем сумму этих чисел. 
старшие числа складываем через команду ADC, то есть учитываем перенос между словами числа. 
сохраняем старшое слово. 
HLT. 
2)Изменение знака 32-х разрядного числа 
инвертируем старшую часть числа, берем доп код младшего числа и складываем возможный перенос со старшей частью числа(CLA и ADC)

=====Команды ветвления=====
-------------------------------------------------------------------|
Наименование		Мнемоника	Код			Описание			   |
-------------------------------------------------------------------|
Переход, если рав	BEQ D		F0XX	IF Z==1 THEN IP+D+1 -> IP  |
-------------------------------------------------------------------| 											 
Переход, если нерав	BNE D		F1XX	IF Z==0 THEN IP+D+1 -> IP  |
-------------------------------------------------------------------|	
Переход, если минус	BMI D		F2XX	IF N==1 THEN IP+D+1 -> IP  |
-------------------------------------------------------------------|
Переход, если плюс 	BPL D		F3XX	IF N==0 THEN IP+D+1 -> IP  | 
-------------------------------------------------------------------|
Переход, если ниже/	BLO D		F4XX	IF C==1 THEN IP+D+1 -> IP  |
перенос				BCS D							               |
-------------------------------------------------------------------|
если выше/			BHIS D		F5XX	IF C==0 THEN IP+D+1 -> IP  | 
нет переноса		BCC D										   |
-------------------------------------------------------------------|
если перепол		BVS D		F6XX	IF V==1 THEN IP+D+1 -> IP  |
-------------------------------------------------------------------|
если нет переп		BVC D		F7XX 	IF V==0 THEN IP+D+1 -> IP  |
-------------------------------------------------------------------|
Переход, если <		BLT D		F8XX IF N⊕V==1 THEN IP+D+1->IP	   |
-------------------------------------------------------------------|
Переход, если >/>=	BGE D		F8XX IF N⊕V==0 THEN IP+D+1->IP	   |
-------------------------------------------------------------------|
Безусловный переход	BR D		CEXX	IP+D+1 -> IP			   |
					JUMP D										   |
-------------------------------------------------------------------|

BLO D используется если число находится ниже, используем эту инструкцию, если используем беззнаковые числа(для арифметики)
BCS D(Brench if Carry Set) необходимо для сдвигов, инструкция не арифметическая(для логики и сдвигов)
В реальности эти команды делают одно и то же
Для сравнения знаковых чисел BLT и BGE
Инструкции с B(Brench) осуществляют локальный переход(может перейти только внутри восьмибитного смещения), а JUMP может перейти на любой адрес.(Возникло исторически)

=====Представление одномерных массивов данных=====
для прочтения и записи в массив требуется 1 команда, так как 1 элемент = 1 слово
адрес вычисляется адрес начала + i-тый элемент и получаем элемент массива
если размерность массива, слова или аккумулятора не совпадают, то: 
1)Элемент меньше слова: (1.1)слова будут содержать много незначащих нулей, память с таким будет работать быстро, но это плохо(курить спайс плохо!)
(1.2)упаковка элементов друг с другом в слова, но тут придется руками работать с массивами, вычислять адреса двух слов, где в теории могут храниться данные, потом делать сдвиги, но это долго, для этого есть компиляторы, которые сами это делают. 
2)Элемент больше слова: нужно считать и размещать, что тоже плохо(случай похож на (1.2))
3)Элемент кратен слову: самый лучший момент, всем ЯПам будет проще, если элемент кратен машинному слову. 

Суммирование элементов массива реализуется с помощью переадресации, штука позволяет изменять код команды.(Но так запрещено в современных процессорах, так как такую штуку реализуют вирусы)

=====Режими Адресации=====
1)Прямая абсолютная, режим 0 
[15-12] - КОП(Код ОПерации)
[11] = 0 
[10-0] - адрес
Адрес команды полностью кодируется в младших 11 битах
Непосредственно загружается в AR из кода команды

2)Прямая относительная (*E**)
[15-12] - КОП
[11] = 1 
[10-8] - Режим 110
[7-0] - Смещение 
В битах 0-7 закодировано смещение относительно адреса следующей команды
Пример: 
AEFD (1010 1110 1111 1101)
A -> LD
E - указывает на режим адресации(прямая относительная)
для вычисления смещения берем 8 младших разрядов (FD) дополняем их до FFFD и добавляем 3 для получения смещения(т.е получаем FFFF) -> LD IP - 3 ✓

3)Косвенная адресация
в прямой адресации мы непосредственно адресуем ячейку, в косвенной в ячейке находится тот адрес, который нам нужен(адрес операнда)(используем для взаимодействия с массивом)
	3.1)косвенная относительная:(*8**)
	[15-12] - КОП
	[11] = 1
	[10-8] = 000
	[7-0] - смещение
	
	3.2)косвенная автоинкрементная(*A**)
	[15-12] - КОП
	[11] = 1
	[10-8] = 010
	[7-0] - смещение
	сначала выбрали элемент массива, а потом увеличили ячейку на +1 
	
	3.3)косвенная автодекрементная(*B**)
	[15-12] - КОП
	[11] = 1
	[10-8] = 011
	[7-0] - смещение
	сначала уменьшили ячейку на 1(когда идем с конца массива), потом взяли элемент
	к адресу начала прибавляем длину, перемещаемся за границу массива 
	
	3.4)Косвенная относительная, со смещением SP(*C**)
	[15-12] - КОП
	[11] = 1
	[10-8] = 100
	[7-0] - смещение
	потактовое выполнение такое же, как и у прямой относительной, но смещение складывается с SP
	
4)прямая загрузка(*F**)
непосредственно загружаем операнд(кодируется в инструкции)
[15-12] - КОП
[11-8] = F
[7-0] - операнд
необходимо сохранять старший разряд восьмибитного числа(для представления отрицательных чисел), поэтому в идет расширение знака в старшие 8 бит, то есть 7 разряд записывается в остальные биты([8-15])

♿️
=====LOOP=====
после циклов AF и OF в DR содержится операнд, а в AR содержится адрес операнда. 
Цикл исполнения(execution): Вычитаем 1 из DR и записываем значение операнда в память. Вычитаем еще 1 единицу и помещаем в буффер(делаем это чтобы проверить результат и узнать, надо ли нам перепрыгнуть 1 инструкцию, LOOP не может устанавливать признаки результата) Проверяем 15 разряд буффера BR(15) положительный ли он. Если да, то продолжаем цикл, если он отрицательный, то перескакиваем 1 инструкцию. 


♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️
|===================================================================|♿️
|					ЛАБА №4					  						|♿️
|===================================================================|♿️
♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️
---Когда выгодно создавать подпрограмму? 
----Размер кода 
----Передача и обработка параметров, возвращение результатов

-Инлайнинг - процесс, обратный выделению кода в подпрограмму(подпрограмма == функция/метод, если очень грубо)

=====Вызов и возвращение из подпрограммы=====♿️

♿️1)Вызов: Dxxx - CALL: 
обычно сначала берет текущий указатель стека, уменьшает его на 1 и кладет туда текущее значение IP, то есть формирует адрес возврата. 

=====ЦИКЛ ИСПОЛНЕНИЯ(execute) CALL=====♿️
после OF DR содержит адрес перехода 
1)DR -> BR; адрес перехода в BR 
2)IP -> DR; подготовить адрес возврата для записи в стек 
3)BR -> IP; переход на подпрограмму 
4)~0 + SP -> SP, AR; уменьшает стек на 1 
5)DR -> MEM(AR); записать адрес возврата 
6)GOTO INT; завершение цикла

♿️2)Возвращение: 0A00 - RET:
поступает так же, как и инструкция CALL только в обратном порядке: возьмет адрес возврата с вершины стека, занесет его в счетчик команд и увеличит стек на 1, то есть вернется в исходное положение. 
Управление возвращается команде с вершины стека. 

♿️3)PUSH
положить на стек значение из аккумулятора можно при помощи команды PUSH, которая сначала уменьшает текущее значение SP на 1, а потом в получившиеся записывает значение AC 

♿️4)POP 
Операция снятия со стека POP действует противоположным образом. Сначала по адресу, содержащемуся в SP читает значение из памяти, а потом увеличивает значение SP на 1. 

=====ЦИКЛ ИСПОЛНЕНИЯ(execute) RET=====♿️
1)SP -> AR; Вершину стека поместить в AR
2)MEM(AR) -> DR; Прочитать адрес возврата 
3)DR -> IP; Вернуться из подпрограммы 
4)SP + 1 -> SP; Увеличить стек на 1
5)GOTO INT; Завершение цикла

♿️
=====STACK POINTER=====♿️
Stack - структура данных по принципу LIFO(last in first out)
стэк в бэвм растет с низу вверх 
♿️Взаимодействие со стеком
1)0C00 - PUSH: AC -> --(SP) == положить в стек(сначала вычитаем единичку, потом кладем)
2)0800 - POP: (SP)+ -> AC == снять со стека (читаем стек, потом прибавляем 1)
3)PICK - взять iтый элемент, такой инструкции в бэвм нет, можно сделать с помощью команды LD + режим адресации со смещением стека.

=====Передача параметров и получение результата=====♿️
♿️1)Аккумулятор(регистр общего назначения)
можно передать 16 параметров(если трактовать 16 логических значений)
это самый быстрый способ передачи параметров

♿️2)Адресуемые ячейки памяти
тут есть небольшая проблема в виде необходимости организовывать

♿️3)Стек
используется повсеместно, работает с ними довольно быстро из за наличия кешей различных уровней

♿️4)Регистровые Окна
Вообще регистровое окно выглядит как круг над кругом, где расположены переменные 
Регистровое окно - один из методов организации работы с регистрами процессора, применяемый для снижения накладных расходов на работу со стеком при вызове подпрограмм. 
В подавляющем большинстве процессоров содержится ограниченное количество регистров — ячеек сверхбыстрой памяти, используемых для хранения служебной информации (служебные регистры) и промежуточных результатов работы программ (регистры общего назначения). В традиционной парадигме в момент вызова подпрограммы процессор должен сохранить своё текущее состояние (содержимое большинства служебных регистров и некоторых регистров общего назначения), передать управление на начало процедуры, а после завершения её работы - восстановить ранее сохранённые значения регистров. На практике это означает необходимость записи десятков или сотен байт информации в оперативную память при каждом вызове процедуры.

В парадигме регистрового окна процессорные регистры общего назначения делятся на глобальные регистры (для хранения глобальных переменных) и регистровый файл, не видимый целиком никакой программе.
Пусть регистровый файл состоит из K регистров, расположенных по кругу. Каждой программе доступны лишь L = L1 + L2 + L3 регистров (L < K), составляющих текущее регистровое окно. Окно делится на три части:

L1 регистров параметров (для получения параметров от вызвавшей программы)
L2 локальных регистров (для хранения промежуточных данных)
L3 временных регистров (для передачи параметров в процедуру)

Перед вызовом подпрограммы текущая программа записывает в выходные регистры значения параметров, которые необходимо передать в подпрограмму. При передаче управления подпрограмме регистровое окно сдвигается, и выходные регистры предыдущей активной программы становятся для подпрограммы входными. Перед обратной передачей управления подпрограмма записывает результаты (возвращаемые значения) в свои входные регистры. Вызвавшая её программа после обратного смещения регистрового окна будет иметь к ним доступ.[1][2]

Указатель на начало текущего регистрового окна хранится в специальном регистре CWP (Current Window Pointer — указатель текущего окна) и изменяется аппаратно.

В случае, если все регистры оказались задействованы, для вызова очередной подпрограммы значения первых регистров необходимо сохранить в оперативной памяти (действие, аналогичное подкачке страниц).

Главное достоинство регистровых окон — отсутствие работы со стеком при вызове подпрограмм. Кроме того, регистровые окна реализуют защиту памяти: подпрограмма не может изменить значения большинства регистров вызвавшей её программы. Среди минусов этого подхода можно отметить наличие максимальной глубины вложенности подпрограмм, при превышении которой накладные расходы при вызове подпрограмм резко возрастают. 


♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️
|===================================================================|♿️
|					ЛАБА №5					  						|♿️
|===================================================================|♿️
♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️

Драйверы - устройство, которое связано с ос, знают о том, как устроено физическое устройство и контроллер, который им управляет. 

1)организуют совместную работу с устройством 
2)"знают" о принципах работы устройства, адресах регистров, поддерживаемых режимах работы
3)управляют единообразным программным интерфейсом

♿️♿️♿️♿️♿️♿️♿️♿️
=====ВВОД-ВЫВОД=====
1)Программно - управляемый
Управляет процессор. 
управляемое программой, условно говоря драйвер, при помощи чтения и записи в регистры контроллера и при помощи алгоритма для устройств, он читает или записывает данные с физического устройства. Контроллер управляет перефирийном шиной. Инициатором управления устройством является программа на процессоре. 
Информацию из устройства надо перенести в память. Занимается этим устройство управления.

2)Управляемый - аппаратурой ПДП(DMA - direct memory access)
Управляющим устройством является контроллер. 
Контроллер берет на себя функцию устройства, которое инициирует обмен с памятью и данные, минуя процессор или минимально его используя, контроллер управляет обменом и пытается напрямую протолкнуть это в память. Делается это при помощи драйверов. Драйверы обычно только устанавливают только режимы работы. 


Быстрее работает управляемый аппаратурой, так как нет паразитных циклов ожидания. Хуже он только тем, что в таком случае контроллеры будут сложнее устроены.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
|==========================|\
|ТОЖЕ САМОЕ ДРУГИМИ СЛОВАМИ|\
|==========================|\
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

1)Программно-управляемый ввод-вывод - все действия, связанные с вводом-выводом управляются процессором. То есть ВУ работает с памятью через процессор. Главный минус подобной стратегии ввода-вывода: процессор простаивает в ожидании готовности ВУ. Процессор будет простаивать до тех пор, пока ВУ не подаст сигнал о готовности передачи информации. Преимущества - легкость реализации. 

2)Прямой доступ к памяти (Direct Memory Access или DMA) — ВУ работает с памятью напрямую, избегая процессор. Такой способ не нагружает процессор , следовательно , намного быстрее. Но для реализации данного подхода требуются более сложные контроллеры, что значительно удорожает конструкцию.

3)Управляемый прерываниями ввод-вывод - работа ввода и вывода также происходит через процессор. Но теперь во время ожидания получения сигнала готовности ВУ передавать информацию, процессор может выполнять какую-либо полезную работу. Как только ВУ готова к обмену - она посылает сигнал готовности и просиходит прерывание (interruption) работы процессора. Такой подход с точки зрения производительности более правильный, но он требует больших усилий на обработку прерываний

В БЭВМ реализованы программно-управляемый ввод-вывод и управляемый прерываниями.

Программно-управляемый ввод-вывод достигается с помощью ожидания непосредственно в аккумуляторе бита статуса. Управляемый прерываниями достигается с помощью системы прерываний.

Прямой доступ к памяти не реализован в БЭВМ, так как нет соответствующих схем в контроллере ВУ.


♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️
=====Синхронный и асинхронный режимы передачи данных=====
Синхронный режим передачи - приемник и передатчик синхронизируются по какому-либо сигналу, а после начинается передача данных. Для данного режима не нужно информировать приемник о готовности передачи.

Синхронный способ передачи данных — способ передачи цифровых данных, при котором приемнику и передатчику известно время передачи данных, то есть, передатчик и приемник работают синхронно, в такт.


NOTE! Несмотря на то, что в лекциях указано, что синхронный обмен можно осуществлять с помощью таймера, Дмитрий Борисович Афанасьев при сдаче ему лаб говорит, что синхронный режим передачи данных в БЭВМ невозможен.

Асинхронный режим передачи - приемник и передатчик никак не синхронизированы. Передатчик информирует приемник о готовности передать данные и затем уже передает данные (В БЭВМ готовность определяется по регистру статуса в каждом ВУ).

Асинхронный способ передачи данных — такой способ передачи цифровых данных от передатчика к приемнику, при котором данные передаются в любой момент времени. При этом для инициации передачи данных используются специальные сигналы о готовности.


♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️
=====КОМАНДЫ, СВЯЗАННЫЕ С ВВОДОМ - ВЫВОДОМ=====

[15-12] = 0001
[11-8] - приказ 
[7-0] - регистр устройства

-------------------------------------------------------------------|
Наименование		Мнемоника	Код		Описание		 		   |
-------------------------------------------------------------------|
Запрет прерываний		DI		1000		--------		 	   |
-------------------------------------------------------------------| 											 
Разрешение прерываний	EI		1100		--------		 	   |
-------------------------------------------------------------------|	
Ввод				IN REG	12xx		REG -> AC		 		   |
-------------------------------------------------------------------|
Вывод				OUT REG	13xx		AC -> REG		 		   | 
-------------------------------------------------------------------|
Прерывание			INT NUM 	18xx		Программное прерыв 	   |
											с вектором NUM	 	   | 
-------------------------------------------------------------------|
Возврат из прерывания	IRET		0B00		(SP)+ -> PS, 	   |
												(SP)+ -> IP		   | 
-------------------------------------------------------------------|

=====Немного про дешифратор===== 
зачем он нужен в вводе-выводе? 
все контроллеры подключены к 1 шине(в шине есть логические составляющие). Дешифратор нужен, чтобы контроллеры внешних устройств могли определить осуществляется ли обращение по шине к ним. 


♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️
=====УСТРОЙСТВО ВУ И КВУ=====
Между ВУ и процессором включены простейшие контроллеры внешнего устройства (КВУ), каждый из которых содержит:
	1)|дешифратор адреса|, позволяющий выделить обращение к данному ВУ среди всех обращений к устройствам ввода-вывода, подключенных к процессору;
	2)|логику управления КВУ|, набор логических схем, позволяющих реагировать и формировать сигналы шины бэвм.
	3)|регистр данных(DR)|, через который происходит обмен данными между процессором и ВУ. 
	4)|регистр состояния(SR - state register)|, в котором хранится информация о готовности ВУ к обмену данными с процессором. В контроллерах простейших ВУ используются однобитовые регистры готовности. 
	5)|регистр управления(MR - management register)|, регистр, в котором хранятся 4 младщих разряда, разряд 3 - для разрешения прерываний от контроллера и разряды с 0 по 2, которые содержат номер вектора прерывания.
Контроллеры ВУ связаны с процессором при помощи системной шины бэвм, в сегменте (или, физически, разъемы для установки контроллеров) которой подсоединяются различные шины со стороны процессора и контроллера: 
	1)шина данных(data0..7) - передача данных в/из процессор(а). 
	2)шина адреса(addr0..7) - адрес внешнего устройства от процессора к КВУ и номер вектора запроса прерывания от КВУ к процессору. 
	3)сигнал запроса прерывания 
	4)сигнал ввода(input) - передача приказа на ввод(IN #reg)
	5)сигнал вывода(output) - передача приказа на вывод(OUT #reg) 
	6)начальный сигнал предоставления прерывания
	7)входящий цепочный сигнал предоставления прерывания 
	8)исходящий цепочный сигнал предоставления прерывания 
	9)сигнал готовности(Rdy), подтверждающий завершение операции ввода-вывода внутри цикла обмена между AC и DR соответ КВУ. В случае операции ввода Rdy подтверждает данные, передаваемые по шине данных, и в обоих случаях операции ввода-вывода сигнализирует о том, что цикл обмена с DR контроллера завершен. 
	10)сигнал синхронизации(Syn) от тактового генератора БЭВМ, который задает временной слот единичного обмена по шине БЭВМ. 

Со стороны процессора к системной шине БЭВМ подключены: 
	1)дешифратор приказа: (DC IO), который преобразует приказ в КОП команды ввода-вывода в набор управляющих сигналов на шине.0-й выход дешифратора активен после команды DI, 1 - для EI, 2 - для IN, 3 - для OUT. Выходы начиная с 4 не используются. 
	2)регистр разрешения прерывания 
	3)регистр прерывания от КВУ
	4)логика управления шин БЭВМ предназначена для подключения и отключения приемо - передатчиков сигналов КВУ и процессора для осуществления обмена CPU с одним из контроллеров в один момент времени. 


♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️
|===================================================================|♿️
|					ЛАБА №6											|♿️
|===================================================================|♿️
♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️♿️

Если сделать программу без спинлупов, то 
У нас в программе только 1 раз проверяется готовность, и пока программа не дойдет до этого места, она не будет никак не реагировать, то есть не обрабатывает сигнали в реальном времени.
ЧТО ЖЕ ДЕЛАТЬ? 
режим работы по прерыванию является решением данной проблемки. 
программа будет выглядеть так: 
["полезная"..... {прерывание, обмен} программа]
{прерывание, обмен} = [[DI][сохранение состояния][обмен с ву][восстановление состояния][EI][iret]]

прерывание ву это программно - аппаратный процесс, который останавливает процесс выполнения "полезной программы" и переходит на подпрограмму обработки прерывания, а после продолжит выполнения полезная программа. 
Проблема в том, что в момент прерывания программа имеет состояние.(необходимо сохранять регистры: регистр состояния, ip, аккумулятор ну и по мелочи что у нас используется.)

А что будет, если в цикле прерывания вызвать еще 1 прерывание? 
Программа написана так, что при обработке прерывания, мы его запрещаем и обрабатываем текущее. 
Поэтому прерывание будет обработано после возвращения в основную программу.

Прерывания обрабатываются так, что чем раньше его обработка стоит, тем оно раньше и обработается. 
В современных процессорах этим занимаются аппаратные контроллеры. 

ЧТО БУДЕТ ЕСЛИ ВЫЗВАТЬ ПРЕРЫВАНИЕ ИЗ ПРЕРЫВАНИЯ?
ну вообще, когда мы переходим на программу обработки прерывания, то мы сначала завершаем прерывание, а потом перед возвратом разрешаем их и возвращаемся в основную программу. Тогда как вернемся, то сразу уйдем на второе прерывание. 
В intel например есть возможность "рекурсивного" вызова прерываний(типа прям из одного вызывать другое), число этой "рекурсивности" что то около 5, оч важно еще учитывать приоритетность прерывания(этим занимается контроллер специальный, в бэвм его нема). В бэвм будем делать только так, чтобы одно нельзя было вызвать прерывание из другого по средствам 
[DI][сохранение состояние программы][обмен с ВУ][восстановление состояния][EI][IRET]. 

=====ВЕКТОР ПРЕРЫВАНИЯ=====
-Совокупность адреса программы обратоки прерывания и регистра состояния(PS)
-Необходимо инициализироать перед началом обработки прерывания: 
	Хотя бы установить на подпрограмму, которая ничего не делает. 
	Ответственность OS и БИОС
-всего 8 вектора, по два слова на вектор 
-на 1 векторе может быть несколько прерываний
-В обычных компиках ОС в начале своей работы инициализирует вектора прерывания, а потом драйверы сами туда регистрируются.
=====Организация прерываний=====
Если контроллер хочет вызвать прерывания, то он устанавливает INTRq(приходит в ps) - требует прерывание, и этот сигнал приходит в процессор и остается там, пока не начнется обработка прерывания. 
БЭВМ формирует 1 управляющий сигнал IntSC(interupt supply chain). Почему chain - потому что проходит через все контроллеры. Если встречается контроллер, где выставлено прерывания, то выставляет на шину адреса вектор своего прерывания.
Процессор видит вектор прерывания и вызывает подпрограмму обработки.
Выставили 1 в SR, процессор увидил выставленный регистр и выдал IntSCi, этот сигнал попадает в кву и открывает вентиль для регистра MR, и номер вектора прерывания попадает в CR.
Почему у SR и MR одинаковые адреса? 
SR - только читают, а MR - только записывают

=====Регистр состояния(PS)=====
[0] = c
[1] = v
[2] = z
[3] = n 
[4] = 0 (0 используется для организации безусловных переходов в МПУ )
[5] = EI(разрешение прерываний)
[6] = IRQ(interuption request(требования прерывания),если установлен, значит выставлен вектор прерывания и запрос прерывания.1)Прерывания разрешены, 2)Есть запрос на прерывание)
[7] = W (состояние тублеров РАБОТА/ОСТАНОВ(1 - работа))
[8] = P (программа) Показывает включен ли тактовый генератор.
 
 
=====Цикл Прерывания=====
if PS(W) = 0 then GOTO STOP; проверка тумблера работа-останов, стоп если останов
if PS(IRQ) = 0 then GOTO INFETCH; если нет прерывания, то на выборку след. команды
IRQSC; Сформировать сигнал предоставления прерывания
~0 + SP -> SP, AR |
IP -> DR		  |; IP -> -(SP)
DR -> MEM(AR)	  |

~0 + SP -> SP, AR |
PS -> DR 		  |; PS -> -(SP)
DR -> MEM(AR)	  |

LTOL(CR) -> BR; младшие 8 разрядов CR(номер вектора прерывания) записать в BR
SHL(BR) -> BR, AR; вычисляем адрес ячейки с переходом на подпрограмму обработки прерывания, как номер вектора * 2

MEM(AR) -> DR; адрес обработчика прерывания в DR 
DR -> IP; затем в IP 
LTOL(BR + 1) -> AR; выбрать адрес следующей ячейки вектора прерывания, ограничивая результат 8-ю разрядами 
MEM(AR) -> DR; содержимое PS обработчика прерывания записать в DR 
DR -> PS; затем установить его в регистр


=====ОТВЕТЫ НА ВОПРОСЫ ПО ЛАБЕ №6=====
1)Особенности организации программ обмена данными с использованием прерываний. Сохранение и восстановление результата: 
	Прерывание — сигнал от программного или аппаратного обеспечения, сообщающий процессору о наступлении какого-либо события, требующего немедленного внимания. В контексте БЭВМ это сигнал о готовности обмена данными с некоторым ВУ.
	Также стоит отметить преимущества над асинхронным режимом передачи данных (если Вы помните, то реализовывать его можно двумя способами: через spin-loop или одну проверку с последующим окном ввода-вывода в циклической полезной программе):
	-процессор не простаивает в ожидании готовности ВУ
	-организованная работа сразу со всеми нужными нам ВУ
	-если все ВУ не готовы к обмену, то процессор занят полезной работой
	Ярким отличием прерываний является обязательное сохранение состояния процессора в момент прерывания, чтобы когда прерывание было обработано, мы смогли вернуться в основную программу и смогли продолжить ее выполнение без разнообразных коллизий.
	Из необходимого нам нужно сохранять: PS, IP(для возврата) и AC, но аккумулятор мы должны сохранить сами, если там есть что то важное.

2)Команды: 
	-DI(запрет прерываний): устанавливает в 5 бит PS 0. команда ввода-вывода, Будут выполняться: IF(insturction fetch), EXC(execution), INT, Не будут выполняться: AF, OF. 
	-EI(разрешение прерываний): устанавливает в 5 бит PS 1. команда ввода-вывода, Будут выполняться: IF(insturction fetch), EXC(execution), INT, Не будут выполняться: AF, OF.  
	-IRET(возврат из прерываний): возвращает состояние процессора до прерывания. безадресная команда. Будут выполняться: IF(insturction fetch), EXC(execution), INT, Не будут выполняться: AF, OF. Выполняется примерно так: из стека достаем необходимые регистры, а потом переходим на выполнение RET, то есть значение из DR помещаем в IP для возврата на место. 

3)Вектор прерывания, преимущества: 
	Вектор прерывания — это совокупность адреса обработчика прерывания и регистра состояния, с которым этот обработчик стартует (данное высказывание справедливо в контексте БЭВМ, в других ЭВМ количество нужных ячеек для вектора прерывания варьируется).
	В БЭВМ доступно 8 векторов прерываний, и расположены они в ячейках памяти 0x0 — 0xF включительно. На один вектор прерывания может приходится несколько прерываний.
	Преимещества: 
	-Быстрая обработка событий(каждый вектор связан напрямую с обработчиком прерывания, что уменьшает задержку на ответ)
	-Эффективное управление ресурсами(обработчики прерываний запускаются тогда и только тогда, когда это необходимо, что не грузит систему)
	-расширяемость и модифицируемость
	-параллелизм и многозадачность(векторы позволяют ОС обрабатывать несколько задач одновременно)

4)Регистр управления ВУ (MR DEV)
	MR 4 бита, 0 - 2 номер вектора прерывания, 3 бит - 1, если прерывания разрешены, 0 - запрещены. Для ВУ они имеют одинаковый адрес вместе с SR, но это потому, что SR - только читаем, а MR - пишем. Поэтому можно к ВУ привязать вектор прерывания другого адреса(например для КВУ-3 привязать вектор прерывания 2)

5)Сигналы шины БЭВМ, назначение, временные диаграммы сигналов Input Output. 


6)биты PS 
ответ выше 

=====Микропрограммное устройство======
Многоуровневая ЭВМ: 
специальный язык (например excel: x=y+z) ->P  алгоритмический язык(например программа на си) -> ассемблер(прога на асм) -> машинные команды(коды машинных команд A020 и тп) -> микропрограммы. 
МПУ(микропрограммное устройство) - выполняет машинные команды процессора при помощи элементарных микроопераций: открытие вентилей и проверкой состояния бита заданного регистра. Работа МПУ разбита на циклы и стадии исполнения команды и циклы пультовых операций.
Существует счетчик микрокоманд, увеличивается на 1 при выполнении микрокоманды(примерно как и IP)
Память состоит из 256 ячеек и каждая ячейка 40 бит. 

2 типа микрокоманд: 
1)ОПЕРАЦИОННАЯ микрокоманда(подает сигналы на вентили управления(в свою очередь, эти вентили выполняют самые простейшие действия, по типу передать из одного регистра в другой))
состоит из нескольких блоков, где каждый отвечает за свою операцию
вентили для операционной микрокоманды:
[39] = 0 (для операционной команды стоит 0)
[38] = halt
[35-34] = IO(input/output)
[33-32] = MEM(запись и чтение памяти)
[31-24] = REG WR(управляют записью в регистр)
[23-15][15-12] = Commutator(разбит на две части: левая часть(установка признака результата + сдвиги),правая часть(управление передачей из старшего в младшие байты слова))
[11-8] = alu
[7-0] = reg rd чтение из регистров
[37-36] - не используются

2)УПРАВЛЯЮЩАЯ микрокоманда(проверяет единственный бит в указанном регистре)
[39] = 1 (для управляющей микрокоманды стоит 1)
[38-33] = не используются
[32] = comp(однобитовое поле сравнения)
[31-24] = addr(адрес перехода)
[23-16] = bit(поле выбора проверяемого бита из за коммутатора)
остальные биты такие же

ВЕНТЕЛЬНЫЕ СХЕМЫ - это электронные ключевые схемы, предназначенные для управления потоком информации из регистров в шины и обратно. 

